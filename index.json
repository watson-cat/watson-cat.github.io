[{"content":"一些概念 工作区: 包含**.git**文件夹的目录就是工作区，也就是你的项目文件夹\n暂存区: .git文件夹中的index文件是暂存区,也叫做stage，是临时保存修改文件的地方\n版本库: .git文件夹是版本库，版本库中存储了许多配置信息，日志信息，文件版本等\n流程: 工作区发生改变后使用命令[ git add . ] 将修改临时保存到暂存区, 使用命令 [ git commit -m \u0026ldquo;提交信息\u0026rdquo;] 提交到版本库\n文件状态 untracked 未跟踪 [未被纳入版本控制] tracked [已被纳入版本控制] Unmodified 未修改状态 Modified 已修改状态 Staged 已暂存状态 常用命令 全局设置 //全局设置 //设置用户名 git config --global user.name \u0026#34;用户名\u0026#34; //设置用户邮箱 git config --global user.email \u0026#34;邮箱地址\u0026#34; 常用 //查看文件状态 git status //将文件的修改添加到暂存区 git add //将暂存区的文件取消暂存或者切换到指定版本 git reset //将暂存区的文件修改提交到版本区 git commit //查看日志 git log ","permalink":"https://watson-cat.github.io/posts/git/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","summary":"一些概念 工作区: 包含**.git**文件夹的目录就是工作区，也就是你的项目文件夹\n暂存区: .git文件夹中的index文件是暂存区,也叫做stage，是临时保存修改文件的地方\n版本库: .git文件夹是版本库，版本库中存储了许多配置信息，日志信息，文件版本等\n流程: 工作区发生改变后使用命令[ git add . ] 将修改临时保存到暂存区, 使用命令 [ git commit -m \u0026ldquo;提交信息\u0026rdquo;] 提交到版本库\n文件状态 untracked 未跟踪 [未被纳入版本控制] tracked [已被纳入版本控制] Unmodified 未修改状态 Modified 已修改状态 Staged 已暂存状态 常用命令 全局设置 //全局设置 //设置用户名 git config --global user.name \u0026#34;用户名\u0026#34; //设置用户邮箱 git config --global user.email \u0026#34;邮箱地址\u0026#34; 常用 //查看文件状态 git status //将文件的修改添加到暂存区 git add //将暂存区的文件取消暂存或者切换到指定版本 git reset //将暂存区的文件修改提交到版本区 git commit //查看日志 git log ","title":"GIT学习笔记"},{"content":"快速使用 ​\tMybatisPlus为我们提供了非常强大的接口来供我们对数据库进行增删改查操作,我们无需写sql语句,只需调用对应接口即可.\n引入maven坐标 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.baomidou\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-plus-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;xxxx\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 编写实体类 @Data //@TableName 指定这个实体类在操作时影响哪张表 @TableName(\u0026#34;tb_users\u0026#34;) public class UserEntity { private int id; private String username; private String password; private int age; private int telephone; private int duties; } 编写Mapper接口 @Mapper public interface UserMapper extends BaseMapper\u0026lt;UserEntity\u0026gt; { //只需要让我们的Mapper接口继承 BaseMapper并给他对应实体类即可 } 使用 @Autowired private UserMapper userMapper; @Override public void addTestData() { UserEntity ue = new UserEntity(); ue.setUsername(\u0026#34;eoezora\u0026#34;); ue.setPassword(\u0026#34;a-test-password\u0026#34;); ue.setAge(24); ue.setTelephone(1145141919); ue.setDuties(1); userMapper.insert(ue); } @Override public List\u0026lt;UserEntity\u0026gt; getAllData() { return userMapper.selectList(null); } 分页功能简单例子 先配置MybatisPlus的分页拦截器, 定义一个配置Bean然后添加拦截器即可\n@Configuration public class MybatisConfig { @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() { MybatisPlusInterceptor mpI = new MybatisPlusInterceptor(); mpI.addInnerInterceptor(new PaginationInnerInterceptor()); return mpI; } } 分页代码的实现\n@Override public void getPageData(int pageIndex, int count) { //创建Page对象储存获取到的分页数据pageIndex 第几页 count 一页几个 IPage page = new Page(pageIndex, count); userMapper.selectPage(page, null); //page.getRecords()获取分页查询的数据 //其他接口方法请看MybatisPlus的文档 System.out.println(page.getRecords()); } DQL编程控制 有关条件构造器的更多文档请看 https://baomidou.com/pages/10c804/\n按条件查询简单例子 //定义一个查询条件(常规模式) QueryWrapper queryWrapper = new QueryWrapper(); //age 是表中的字段名 //下面两行代表 查询 age 这个字段值大于25小于55的数据 queryWrapper.ge(\u0026#34;age\u0026#34;, 25); queryWrapper.lt(\u0026#34;age\u0026#34;, 55); //链式编程格式 LambdaQueryWrapper\u0026lt;UserEntity\u0026gt; qw= new LambdaQueryWrapper\u0026lt;\u0026gt;(); //大于10 或 小于25 qw.lt(UserEntity::getId, 10).or().gt(UserEntity::getId, 25); IPage page = new Page(pageIndex, count); //查询条件给BaseMapper里的方法 userMapper.selectPage(page, qw); System.out.println(page.getRecords()); NULL判定 QueryWrapper qw = new QueryWrapper(); //当user.getAge()为null时 下面这样不参加条件判断 qw.lt(null != user.getAge(), UserEntity::getId, 10); //支持链式编程 上述代码中, 当user.getAge()为null时, 则该条件语句不会参与到本次查询的条件参数里\n查询投影 介绍: 在查询时不返回全部数据，只返回某些列的数据，这种操作称为投影查询。一般使用SELECT 列1, 列2, 列3 FROM \u0026lt;表名\u0026gt; WHERE \u0026lt;条件\u0026gt;\nMybatisPlus使用查询投影\n一般方式\nQueryWrapper\u0026lt;UserEntity\u0026gt; queryWrapper = new QueryWrapper\u0026lt;\u0026gt;(); queryWrapper.select(\u0026#34;列1\u0026#34;,\u0026#34;列2\u0026#34;, \u0026#34;列3\u0026#34;); Lambda形式\nLambdaQueryWrapper\u0026lt;UserEntity\u0026gt; qw= new LambdaQueryWrapper\u0026lt;\u0026gt;(); qw.select(UserEntity::getId, UserEntity::getAge, UserEntity::getPassword); 字段映射与表名映射 有关注解的属性请查看源码文档\n//映射字段 @TableField(\u0026#34;pwd\u0026#34;) //这里的是数据库表里的字段名 private String password; //映射表名 @TableName(\u0026#34;tb_users\u0026#34;) //这里的是数据库表名 public class UserEntity { } ","permalink":"https://watson-cat.github.io/posts/mybatis-plus/mybatis-plus/","summary":"快速使用 ​\tMybatisPlus为我们提供了非常强大的接口来供我们对数据库进行增删改查操作,我们无需写sql语句,只需调用对应接口即可.\n引入maven坐标 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.baomidou\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-plus-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;xxxx\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 编写实体类 @Data //@TableName 指定这个实体类在操作时影响哪张表 @TableName(\u0026#34;tb_users\u0026#34;) public class UserEntity { private int id; private String username; private String password; private int age; private int telephone; private int duties; } 编写Mapper接口 @Mapper public interface UserMapper extends BaseMapper\u0026lt;UserEntity\u0026gt; { //只需要让我们的Mapper接口继承 BaseMapper并给他对应实体类即可 } 使用 @Autowired private UserMapper userMapper; @Override public void addTestData() { UserEntity ue = new UserEntity(); ue.setUsername(\u0026#34;eoezora\u0026#34;); ue.setPassword(\u0026#34;a-test-password\u0026#34;); ue.setAge(24); ue.setTelephone(1145141919); ue.setDuties(1); userMapper.insert(ue); } @Override public List\u0026lt;UserEntity\u0026gt; getAllData() { return userMapper.","title":"JavaWEB笔记-MyBatis-Plus"},{"content":"异常处理器 出现异常现象的常见位置与诱因如下:\n框架内部抛出的异常: 使用不合规导致\n数据层抛出的异常: 因外部服务器故障导致(如: 服务器访问超时)\n业务层抛出的异常: 因业务逻辑编写错误导致(如: 遍历业务编写不当, 导致索引异常)\n表现层抛出的异常: 因数据收集, 检验等规则导致(如: 不匹配的数据类型)\n工具类抛出的异常: 因工具类编写不严谨(如: 必要的释放的链接长期未释放等)\n所有异常均抛到表现层进行处理\n定义一个异常处理器 //与表现层的注解一致, 我使用的时rest风格的所以使用下面那个 @RestControllerAdvice //@ControllerAdvice @RestControllerAdvice public class UserExceptionAdvice { /** * 括号里是要处理的异常类型 * 当出现异常时, 会调用下面这个方法进行处理 **/ @ExceptionHandler(Exception.class) public Result\u0026lt;Object\u0026gt; doException(Exception e) { return Result.error(\u0026#34;错误, 出现异常\u0026#34;); } } 项目异常处理方案 业务异常(BusinessException) 规范的用户行为产生的异常\n不规范的用户行为操作产生的异常\n解决方案: 发送对应消息给用户, 提醒规范操作\n系统异常(SystemException) 项目运行过程中可预计但不可避免的异常\n解决方案: 发送固定消息给用户.安抚用户, 发送特定消息给运维人员,提醒维护, 记录日志\n其他异常(Exception) 开发者未预期到的异常\n解决方案: 发送固定消息给用户.安抚用户, 发送特定消息给运维人员,提醒维护, 记录日志\n项目中的使用 自定义异常\n/** * 定义一个自定义异常 * code 是状态码 */ public class BusinessException extends RuntimeException{ private Integer code; public BusinessException() { } public BusinessException(int code, String message) { super(message); this.code = code; } public BusinessException(int code, String message, Throwable cause) { super(message, cause); this.code = code; } public BusinessException(int code, Throwable cause) { super(cause); this.code = code; } public BusinessException(int code, String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) { super(message, cause, enableSuppression, writableStackTrace); this.code = code; } public Integer getCode() { return code; } } 在可能会出异常的位置利用try catch把代码块包围起来然后抛出自定义异常\n@GetMapping(\u0026#34;/{id}\u0026#34;) public User OnAccountGet(@PathVariable int id) { //模拟系统错误 if(id == 1) { throw new BusinessException(233,\u0026#34;错误, 系统出现异常\u0026#34;); } //模拟系统错误 try{ int i = 1/ 0; } catch (Exception e) { throw new BusinessException(255,\u0026#34;错误, 系统禁止此操作\u0026#34;); } return userService.selectUserByID(id); } 在异常处理器对异常进行处理\n@RestControllerAdvice public class UserExceptionAdvice { //可预期的业务异常处理 @ExceptionHandler(BusinessException.class) public Result\u0026lt;Object\u0026gt; doBusinessException(BusinessException e) { //日志记录 //提醒运营人员 //提醒开发者 return Result.error(e.getCode(),null, e.getMessage()); } //其他的不可预期的异常处理 @ExceptionHandler(Exception.class) public Result\u0026lt;Object\u0026gt; doException(Exception e) { //日志记录 //提醒运营人员 //提醒开发者 return Result.error(e.getMessage()); } } 以上两个异常将会各返回两个JSON数据\n{ \u0026#34;success\u0026#34;: false, \u0026#34;code\u0026#34;: 233, \u0026#34;msg\u0026#34;: \u0026#34;错误, 系统出现异常\u0026#34;, \u0026#34;data\u0026#34;: null }, { \u0026#34;success\u0026#34;: false, \u0026#34;code\u0026#34;: 255, \u0026#34;msg\u0026#34;: \u0026#34;错误, 系统禁止此操作\u0026#34;, \u0026#34;data\u0026#34;: null } ","permalink":"https://watson-cat.github.io/posts/spring/spring-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","summary":"异常处理器 出现异常现象的常见位置与诱因如下:\n框架内部抛出的异常: 使用不合规导致\n数据层抛出的异常: 因外部服务器故障导致(如: 服务器访问超时)\n业务层抛出的异常: 因业务逻辑编写错误导致(如: 遍历业务编写不当, 导致索引异常)\n表现层抛出的异常: 因数据收集, 检验等规则导致(如: 不匹配的数据类型)\n工具类抛出的异常: 因工具类编写不严谨(如: 必要的释放的链接长期未释放等)\n所有异常均抛到表现层进行处理\n定义一个异常处理器 //与表现层的注解一致, 我使用的时rest风格的所以使用下面那个 @RestControllerAdvice //@ControllerAdvice @RestControllerAdvice public class UserExceptionAdvice { /** * 括号里是要处理的异常类型 * 当出现异常时, 会调用下面这个方法进行处理 **/ @ExceptionHandler(Exception.class) public Result\u0026lt;Object\u0026gt; doException(Exception e) { return Result.error(\u0026#34;错误, 出现异常\u0026#34;); } } 项目异常处理方案 业务异常(BusinessException) 规范的用户行为产生的异常\n不规范的用户行为操作产生的异常\n解决方案: 发送对应消息给用户, 提醒规范操作\n系统异常(SystemException) 项目运行过程中可预计但不可避免的异常\n解决方案: 发送固定消息给用户.安抚用户, 发送特定消息给运维人员,提醒维护, 记录日志\n其他异常(Exception) 开发者未预期到的异常\n解决方案: 发送固定消息给用户.安抚用户, 发送特定消息给运维人员,提醒维护, 记录日志\n项目中的使用 自定义异常\n/** * 定义一个自定义异常 * code 是状态码 */ public class BusinessException extends RuntimeException{ private Integer code; public BusinessException() { } public BusinessException(int code, String message) { super(message); this.","title":"JavaWEB笔记-Spring异常处理"},{"content":"快速入门 SpringMVC与Tomcat整合 需要注意的是Tomcat 10与spring mvc不兼容. 请使用tomcat 8\n导入maven坐标 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javax-servlet-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.0.1\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-webmvc\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 创建控制类 //@Controller 注解表示这是一个Spring Bean @Controller public class AccountController { //访问入口 @RequestMapping(\u0026#34;/sign-in\u0026#34;) //设置返回值为响应内容 @ResponseBody public String OnAccountSignIn() { System.out.println(\u0026#34;Account: Sign In\u0026#34;); return \u0026#34;{\u0026#39;msg\u0026#39;:\u0026#39;success\u0026#39;}\u0026#34;; } } 创建Spring配置类 /** * Spring配置类 * 设置组件扫描路径,加载Bean */ @Configuration @ComponentScan(\u0026#34;com.eoezora\u0026#34;) public class SpringConfig { } 创建SpringMVC配置 /** * 定义一个Servlet容器启动的配置类,在里面加载Spring的配置 */ public class ServletContainersInitConfig extends AbstractDispatcherServletInitializer { /** * 加载Spring mvc 容器配置 * SpringMVC的配置 */ @Override protected WebApplicationContext createServletApplicationContext() { AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext(); //SpringMVConfig.class context.register(SpringMVConfig.class); return context; } /** * 设置哪些请求归SpringMVC处理 */ @Override protected String[] getServletMappings() { /** * {\u0026#34;/\u0026#34;} 表示所有请求归SpringMVC处理 * 这个设置会把静态资源也给Spring处理 * 因为静态资源要给tomcat处理, 所以这个操作会导致静态资源访问不到 */ return new String[]{\u0026#34;/\u0026#34;}; } /** * 加载Spring容器配置 * Spring的配置 */ @Override protected WebApplicationContext createRootApplicationContext() { AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext(); //SpringConfig.class context.register(SpringConfig.class); return context; } } 简化版\n/** * 定义一个Servlet容器启动的配置类,在里面加载Spring的配置 */ public class ServletContainersInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer { /** * 加载Spring mvc 容器配置 * SpringMVC的配置 */ @Override protected Class\u0026lt;?\u0026gt;[] getRootConfigClasses() { return new Class[]{SpringConfig.class}; } /** * 加载Spring容器配置 * Spring的配置 */ @Override protected Class\u0026lt;?\u0026gt;[] getServletConfigClasses() { return new Class[]{SpringConfig.class}; } /** * 设置哪些请求归SpringMVC处理 */ @Override protected String[] getServletMappings() { /** * {\u0026#34;/\u0026#34;} 表示所有请求归SpringMVC处理 */ return new String[]{\u0026#34;/\u0026#34;}; } } 静态资源访问不到的解决方式\n@Configuration public class SpringMVCSupport extends WebMvcConfigurationSupport { @Override protected void addResourceHandlers(ResourceHandlerRegistry registry) { //当访问/pages/xxx时,走/pages目录里的内容 registry.addResourceHandler(\u0026#34;/pages/**\u0026#34;).addResourceLocations(\u0026#34;/pages/\u0026#34;); } } 工作流程分析 以上方例子为例\n服务器初始化 服务器启动, 执行ServletContainersInitConfig类初始化web容器 执行 createServletApplicationContext() 方法, 创建 WebApplicationContext 对象 加载SpringConfig 执行 @ComponentScan(\u0026ldquo;com.eoezora\u0026rdquo;) 扫描对应包里的Bean 加载 Controller [AccountController.calss] 每个 @RequestMapping 里都是一个方法 执行 getServletMappings() 方法, 定义所有请求都走SpringMVC 单词请求过程 发送请求: http://localhost/sign-in web容易检测到所有请求都走SpringMVC, 所以转交给SpringMVC处理 解析请求路径 localhost/sign-in -\u0026gt; sign-in 根据请求路径,执行对象方法 sign-in -\u0026gt; OnAccountSignIn() 执行方法 -\u0026gt; OnAccountSignIn() 检测到有 @ResponseBody 将方法返回值作为响应体返回给请求方 Bean的加载控制 在开发中SpringMVC一般只管controller包下的bean,也就是表现层的bean.\n而Spring管理的是业务层,数据层的bean (service,dao)\n应功能不同, 我们应该避免spring错误地加载到SpringMVC的bean\nSpringMVC相关Bean管理 SpringMVC加载的bean对应的包应均在com.xxx.controller里,在扫描时,精确写到 com.xxx.controller\nSpring相关Bean管理 Spring加载Bean设定扫描范围为com.xxxx, 然后排除掉controller包内的bean\nSpring加载Bean设定扫描范围为精准范围, 如com.xxx.service, com.xxx.dao\n例子\nspring精准扫描\n@Configuration @ComponentScan({\u0026#34;com.eoezora.service\u0026#34;, \u0026#34;com.eoezora.dao\u0026#34;}) public class SpringConfig { } 排除指定的bean\n/** * 按照注解过滤 * 排除注解为 @Controller 的Bean * includeFilters: 包含 * excludeFilters: 排除 */ @ComponentScan(value = \u0026#34;com.eoezora\u0026#34;, excludeFilters = @ComponentScan.Filter( type = FilterType.ANNOTATION, classes = Controller.class )) 请求与响应 请求映射路径 @RequestMapping: 设置当前控制器的请求路径, 可以设置在方法跟类上, 设置在类上表示整个类的方法访问前缀, 加载方法上表示访问的具体路径.\n请求映射路径重复问题: 在开发中，我们可能会遇到不同模块同个访问入口名的问题, 一般解决方法是在访问路口前面加上模块的名字, 比如: User和Book模块下都有一个save的入口.如果都在这两模块里定义save. Spring启动时会报错, 只需在save前面加上模块名即可解决\n@Controller public class UserController { //访问入口前面加上模块名解决入口重复问题 @RequestMapping(\u0026#34;/user/save\u0026#34;) public void OnSave() { System.out.println(\u0026#34;user save\u0026#34;); } } @Controller public class BookController { //访问入口前面加上模块名解决入口重复问题 @RequestMapping(\u0026#34;/book/save\u0026#34;) public void OnSave() { System.out.println(\u0026#34;Book save\u0026#34;); } } 上述的方法可以解决入口重复的问题, 但是当几个模块里有很多的重名入口时, 你一个个去写会很耗时, 且耦合度很高.所以我们可以把 @RequestMapping(\u0026quot;/模块名\u0026quot;) 写在类上, 如下方所示, 访问\n@Controller //在类上添加 @RequestMapping(\u0026#34;/user\u0026#34;), @RequestMapping(\u0026#34;/user\u0026#34;) public class UserController { //访问入口前面加上模块名解决入口重复问题 @RequestMapping(\u0026#34;/save\u0026#34;) public void OnSave() { System.out.println(\u0026#34;user save\u0026#34;); } } @Controller @RequestMapping(\u0026#34;/book\u0026#34;) public class BookController { //访问入口前面加上模块名解决入口重复问题 @RequestMapping(\u0026#34;/save\u0026#34;) public void OnSave() { System.out.println(\u0026#34;Book save\u0026#34;); } } 访问路劲都是: https://localhost/user/save 或 https://localhost/book/save\n请求参数 普通参数 url地址传参, 地址参数名和形参变量名相同, 定义形参即可接收参数\n例如: 请求地址是 http://127.0.0.1/testAccount/login?name=test\u0026amp;password=35r356464467\n@RequestMapping(\u0026#34;/login\u0026#34;) @ResponseBody public String OnAccountSignIn(String name, String password) { System.out.println(\u0026#34;Account: \u0026#34; + name + \u0026#34; Sign In - \u0026#34; + password); return \u0026#34;success\u0026#34;; } //打印 Account: test Sign In - 35r356464467 形参变量名与请求参数名不一样怎么办？通过@RequestParam 把形参变量与请求变量绑定一起\n//形参与请求参数名字不一样的 @RequestMapping(\u0026#34;/login\u0026#34;) @ResponseBody public String OnAccountSignIn(@RequestParam(\u0026#34;name\u0026#34;) String userName, @RequestParam(\u0026#34;name\u0026#34;) String pwd) { System.out.println(\u0026#34;Account: \u0026#34; + userName + \u0026#34; Sign In - \u0026#34; + pwd); return \u0026#34;success\u0026#34;; } //打印 Account: test Sign In - 35r356464467 POJO参数 spring可以会按请求参数跟你给的形参pojo的属性名进行匹配. 并自动赋值, 且支持为pojo里的引用行对象赋值, 以下为例子\n假设请求地址为: http://127.0.0.1:81/testAccount/login?name=test\u0026amp;password=35r356464467\u0026amp;address.city=煎鱼街\u0026amp;address.country=荔枝星\n控制器访问入口\n@RequestMapping(\u0026#34;/login\u0026#34;) @ResponseBody public String OnAccountSignIn(User user) {//这里形参是一个POJO System.out.println(\u0026#34;Account: \u0026#34; + user.getName() + \u0026#34; Sign In - \u0026#34; + user.getPassword()); return user.toString(); } User类\n@Repository @NoArgsConstructor @AllArgsConstructor @Getter @Setter @ToString public class User { private String name; private String password; private Address address; } Address类\n@Repository @NoArgsConstructor @AllArgsConstructor @Getter @Setter @ToString public class Address { private String country; private String city; } Spring会把接受到的参数一一与形参的属性名进行匹配,并赋值, 且当形参属性有引用类型时, Spring也会自动解析并赋值.\nname=test\u0026amp;password=35r356464467\u0026amp;address.city=煎鱼街\u0026amp;address.country=荔枝星\n参数有name password address.city address.country 其中name和password是基本数据类型会直接赋值给User中的name和password, 而address.city address.country是引用数据类型则会赋值给对象Address中的city和country\n数组参数 有时候我们的参数会以数组的形式过来\n假设请求地址为: http://127.0.0.1:81/testAccount/login?name=test\u0026amp;password=35r356464467\u0026amp;address.city=煎鱼街\u0026amp;address.country=荔枝星\u0026amp;hobby=c\u0026amp;hobby=t\u0026amp;hobby=r\u0026amp;hobby=l\n@RequestMapping(\u0026#34;/login\u0026#34;) @ResponseBody public String OnAccountSignIn(User user, @RequestParam List\u0026lt;String\u0026gt; hobby) { System.out.println(user.toString()); return user + hobby.toString(); } //打印 {name=\u0026#39;test\u0026#39;, password=\u0026#39;35r356464467\u0026#39;, address=Address(country=afafgfg, city=asdfas)}[c, t, r, l] 需要注意的是hobby 可以是数组String[] 也可以是集合,若写集合则需要添加注解@RequestParam\nJSON数据参数 导入坐标\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-databind\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.14.0-rc1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 在Spring配置类开启json解析支持\n@EnableWebMvc JSON数据模型, 参考User类与Address类\n[ //第一条数据 { \u0026#34;name\u0026#34;: \u0026#34;eoezora\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;afgeajgoij4354\u0026#34;, \u0026#34;address\u0026#34;: { \u0026#34;country\u0026#34;: \u0026#34;afjwoif\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;awffg\u0026#34; } }, //第二条数据 { \u0026#34;name\u0026#34;: \u0026#34;eoezora42\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;afgeajgoij43555554\u0026#34;, \u0026#34;address\u0026#34;: { \u0026#34;country\u0026#34;: \u0026#34;afjwoif\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;awffg\u0026#34; } } ] 访问入口\n因为JSON数据是在Body里的所以需要在对应形参面前添加@RequestBody, 且一个方法只能添加一个.\n//访问入口 @RequestMapping(\u0026#34;/login\u0026#34;) //设置返回值为响应内容 @ResponseBody public String OnAccountSignIn(@RequestBody List\u0026lt;User\u0026gt; jsonData) { System.out.println(jsonData); return \u0026#34;\u0026#34;; } //控制台输出 [{name=\u0026#39;eoezora\u0026#39;, password=\u0026#39;afgeajgoij4354\u0026#39;, address=Address(country=afjwoif, city=awffg)}, {name=\u0026#39;eoezora42\u0026#39;, password=\u0026#39;afgeajgoij43555554\u0026#39;, address=Address(country=afjwoif, city=awffg)}] 日期类型参数传递 日期时间类型的参数, 由于日期类型数据基于系统不同格式也不尽相同, 例如以下几种\nSpringMVC默认支持自动解析第二种格式的时间, 也就是2012/04/01\n2012-04-01 2012/04/01 04/01/2012 遇到时间类型参数的时间格式不一致时, 我们可以使用注解 @DateTimeFormat 注解在方法形参上. 其中pattern属性为时间格式\n@RequestMapping(\u0026#34;/time\u0026#34;) @ResponseBody public String OnTime(@DateTimeFormat(pattern = \u0026#34;yyyy-MM-dd\u0026#34;) Date date) { System.out.println(date); return \u0026#34;\u0026#34;; } //输入 http://127.0.0.1:81/time?date=2021-04-01 //输出Thu Apr 01 00:00:00 CST 2021 响应json数据 响应数据需要在对应方法添加@ResponseBody注解, 作用是设置当前方法的返回值为此次请求的响应内容,一般我们返回的响应内容都是JSON数据, 只要我们添加依赖 jackson-databind SpringMVC就会自动把我们的POJO对象解析成JSON数据并返回响应, 同时Jackson也会把接受的参数解析成POJO参数供我们使用. 这里演示的是多个POJO对象, 用了集合, 也是可以接受单个POJO的\n@RequestMapping(\u0026#34;/login\u0026#34;) @ResponseBody public List\u0026lt;User\u0026gt; OnAccountSignIn(@RequestBody List\u0026lt;User\u0026gt; jsonData) { System.out.println(jsonData); return jsonData; } /** * 输入http://127.0.0.1:81/login * [ { \u0026#34;name\u0026#34;: \u0026#34;eoezora\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;asdexasdex\u0026#34;, \u0026#34;address\u0026#34;: { \u0026#34;country\u0026#34;: \u0026#34;usa\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;dc\u0026#34; } }, { \u0026#34;name\u0026#34;: \u0026#34;eoezora17\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;asdexasdex\u0026#34;, \u0026#34;address\u0026#34;: { \u0026#34;country\u0026#34;: \u0026#34;usa\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;dc\u0026#34; } } ] **/ //输出[{name=\u0026#39;eoezora\u0026#39;, password=\u0026#39;asdexasdex\u0026#39;, address=Address(country=usa, city=dc)}, {name=\u0026#39;eoezora17\u0026#39;, password=\u0026#39;asdexasdex\u0026#39;, address=Address(country=usa, city=dc)}] REST风格开发 介绍 REST: Representational State Transfer - 表现形式状态转换\nREST是一种风格,是一种约定,不是规范,可以被打破\n根据REST风格对资源进行访问称为RESTfull\n传统风格: http://127.0.0.1:81/user/getByID?id=114514 获取用户 http://127.0.0.1:81/user/login 用户登录 REST风格: http://127.0.0.1:81/user/114514 获取用户 http://127.0.0.1:81/user 用户登录 优点:\n书写简化 隐藏访问行文, 无法得知地址获取资源操作信息 案例 /** * 以POST方式请求 * 访问路径: https://localhost/users/1 * @param id 地址上的参数 1 参数名字要与 value = \u0026#34;/users/{id}\u0026#34;中的一致 * 方法上的形参前面要添加注解 @PathVariable 表示这是一个RESTfull风格的参数 */ @RequestMapping(value = \u0026#34;/users/{id}\u0026#34;, method = RequestMethod.POST) public void OnAccountLogin(@PathVariable String id) { System.out.println(\u0026#34;login request data -\u0026gt; \u0026#34; + id); } /** * 以GET方式请求 * 访问路径: https://localhost/users/1 * @param id 地址上的参数 1 参数名字要与 value = \u0026#34;/users/{id}\u0026#34;中的一致 * 方法上的形参前面要添加注解 @PathVariable 表示这是一个RESTfull风格的参数 */ @RequestMapping(value = \u0026#34;/users/{id}\u0026#34;, method = RequestMethod.GET) public void OnAccountRegister(@PathVariable String id) { System.out.println(\u0026#34;register request data -\u0026gt; \u0026#34; + id); } 简化 一个控制类里会有很多的入口方法, 如果一个个写@RequestMapping,然后指定请求方式 GET or POST,访问入口会很麻烦,重复的代码会很多. 我们可以提取共同点出来. 例如以下例子\n一般写法 @Controller public class AccountController { @RequestMapping(value = \u0026#34;/users/{id}\u0026#34;, method = RequestMethod.POST) @ResponseBody public String OnAccountLogin(@PathVariable String id) { System.out.println(\u0026#34;login request data -\u0026gt; \u0026#34; + id); return \u0026#34;\u0026#34;; } @RequestMapping(value = \u0026#34;/users/{id}\u0026#34;, method = RequestMethod.GET) @ResponseBody public String OnAccountRegister(@PathVariable String id) { System.out.println(\u0026#34;register request data -\u0026gt; \u0026#34; + id); return \u0026#34;\u0026#34;； } } 简化后 /** * 如果该Controller里的所有方法都有返回值,那么可以使用 @RestController * @RestController 等于 @Controller和@ResponseBody */ @RestController /** * 提取入口的访问前缀注解到类上 * 代表该类下的所有访问入口都带此前缀 * http://localhost/users/xxx */ @RequestMapping(\u0026#34;/users\u0026#34;) public class AccountController { /** * POST请求的入口 * @param id 路径参数 * 示例请求地址 http://localhost/users/1 */ @PostMapping(\u0026#34;/{id}\u0026#34;) public void OnAccountLogin(@PathVariable String id) { System.out.println(\u0026#34;login request data -\u0026gt; \u0026#34; + id); } /** * GET请求的入口 * @param id 路径参数 * 示例请求地址 http://localhost/users/1 */ @GetMapping(\u0026#34;/{id}\u0026#34;) public void OnAccountRegister(@PathVariable String id) { System.out.println(\u0026#34;register request data -\u0026gt; \u0026#34; + id); } } ","permalink":"https://watson-cat.github.io/posts/spring/spring-mvc/","summary":"快速入门 SpringMVC与Tomcat整合 需要注意的是Tomcat 10与spring mvc不兼容. 请使用tomcat 8\n导入maven坐标 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javax-servlet-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.0.1\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-webmvc\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 创建控制类 //@Controller 注解表示这是一个Spring Bean @Controller public class AccountController { //访问入口 @RequestMapping(\u0026#34;/sign-in\u0026#34;) //设置返回值为响应内容 @ResponseBody public String OnAccountSignIn() { System.out.println(\u0026#34;Account: Sign In\u0026#34;); return \u0026#34;{\u0026#39;msg\u0026#39;:\u0026#39;success\u0026#39;}\u0026#34;; } } 创建Spring配置类 /** * Spring配置类 * 设置组件扫描路径,加载Bean */ @Configuration @ComponentScan(\u0026#34;com.eoezora\u0026#34;) public class SpringConfig { } 创建SpringMVC配置 /** * 定义一个Servlet容器启动的配置类,在里面加载Spring的配置 */ public class ServletContainersInitConfig extends AbstractDispatcherServletInitializer { /** * 加载Spring mvc 容器配置 * SpringMVC的配置 */ @Override protected WebApplicationContext createServletApplicationContext() { AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext(); //SpringMVConfig.","title":"JavaWEB笔记-SpringMVC"},{"content":"简介 事务作用: 在数据层保证一系列数据库操作同时成功或同时失败\nSpring事务作用: 在数据层或业务层的一些列数据库操作同时成功或同时失败\n例子 通过相同的数据源DataSource来管理sql的事务\n在业务层的接口上, 要添加Spring事务的方法上添加注解 @Transactional, 一般是使用在业务层接口上,不会用在实现类上. @Transactional也可以使用在类上,使用在类上表示该类所有方法都开启事务 设置事务管理器 @Bean public PlatformTransactionManager transactionManager(DataSource dataSource) { DataSourceTransactionManager transactionManager = new DataSourceTransactionManager(); transactionManager.setDataSource(dataSource); return transactionManager; } 在Spring设置里打开注解事务驱动 //开起启用注解事务 @EnableTransactionManagement //事务简单例子 //本方法中有三个事务分别是 test_Tran() print_a() print_b() //在实际运行中print_a()和print_b()会加入到test_Tran()中形成一个新的事务, 从而实现print_a()和print_b()的同时成功或同时失败 @Transactional public void test_Tran(){ common.print_a(); //... common.print_b(); } class common { @Transactional public void print_a() { sout(\u0026#34;2333\u0026#34;); } @Transactional public void print_b() { sout(\u0026#34;12345\u0026#34;); } } 事务角色 事务管理员: 发起事务方, 在Spring中通常指代业务开始事务的方法\n事务协调员: 加入事务方, 在Spring中通常指数据层方法,也可以是业务层方法\n在sql中事务是隔离互不影响的, 比如事务T1成功-事务T2失败, 这两都不会回滚,而Spring的事务, 会让指定的事务T1,T2加入自己的事务中成为一个新的事务T3,T3如果执行到某一布出错就会回滚事务,\n事务配置 属性 作用 示例 readOnly 设置事务是否只读 readOnly=true 只读 timeout 设置事务超时时间 timeout=-1 永不超时 rollbackFor 设置事务回滚异常(Class : Class) rollbackFor = (Exception.class) rollbackForClassName 设置事务回滚异常(className : String) rollbackForName=\u0026ldquo;Exception.class\u0026rdquo; noRollbackFor 设置事务不回滚异常(Class : Class) 同上 noRollbackForClassName 设置事务不回滚异常(className : String) 同上 propagation 设置事务传播行为 事务传播行为 传播属性 作用 人话 REQUIRED 如果管理员有事务就加入,没有就新建 拥有此属性的方法,被调用时,调用者有事务此方法就加入到调用者的事务中 REQUIRES_NEW 不管, 管理员有没有事务,都创建一个新事物 拥有此属性的方法,被调用时,调用者不管有没有事务此方法都不加入,自己创建一个新的 SUPPORTS 如果管理员有事务就加入,没有无操作 拥有此属性的方法,,被调用时,调用者有事务就加入,没有就照常运行 NOT_SUPPORTED 不管, 管理员有没有事务, 都不做出操作 拥有此属性的方法,,被调用时,不管调用者有没有事务,此方法都加入 MANDATORY 如果管理员有事务就加入,没有就报错 拥有此属性的方法,要求此方法一定带事务运行 NERVER 如果管理员有事务就报错,没有就无操作 拥有此属性的方法,要求此方法一定不带事务运行 NESTED 创建savePoint, 一旦事务回滚, 事务将回滚到savePoint处,由客户响应提交/回滚 ","permalink":"https://watson-cat.github.io/posts/spring/spring-%E4%BA%8B%E5%8A%A1/","summary":"简介 事务作用: 在数据层保证一系列数据库操作同时成功或同时失败\nSpring事务作用: 在数据层或业务层的一些列数据库操作同时成功或同时失败\n例子 通过相同的数据源DataSource来管理sql的事务\n在业务层的接口上, 要添加Spring事务的方法上添加注解 @Transactional, 一般是使用在业务层接口上,不会用在实现类上. @Transactional也可以使用在类上,使用在类上表示该类所有方法都开启事务 设置事务管理器 @Bean public PlatformTransactionManager transactionManager(DataSource dataSource) { DataSourceTransactionManager transactionManager = new DataSourceTransactionManager(); transactionManager.setDataSource(dataSource); return transactionManager; } 在Spring设置里打开注解事务驱动 //开起启用注解事务 @EnableTransactionManagement //事务简单例子 //本方法中有三个事务分别是 test_Tran() print_a() print_b() //在实际运行中print_a()和print_b()会加入到test_Tran()中形成一个新的事务, 从而实现print_a()和print_b()的同时成功或同时失败 @Transactional public void test_Tran(){ common.print_a(); //... common.print_b(); } class common { @Transactional public void print_a() { sout(\u0026#34;2333\u0026#34;); } @Transactional public void print_b() { sout(\u0026#34;12345\u0026#34;); } } 事务角色 事务管理员: 发起事务方, 在Spring中通常指代业务开始事务的方法\n事务协调员: 加入事务方, 在Spring中通常指数据层方法,也可以是业务层方法","title":"JavaWEB笔记-Spring事务"},{"content":"Maven坐标 \u0026lt;!--德鲁伊连接池--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;druid\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.13-SNSAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; ","permalink":"https://watson-cat.github.io/posts/spring/spring-boot/","summary":"Maven坐标 \u0026lt;!--德鲁伊连接池--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;druid\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.13-SNSAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; ","title":"JavaWEB笔记-SpringBoot"},{"content":"入门案例 定义一个拦截器Bean,实现HandlerInterceptor接口\n@Component public class UserInterceptor implements HandlerInterceptor { //拦截之前触发 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(\u0026#34;preHandle\u0026#34;); //返回false表示不放行 中止原始操作, 也会影响拦截器链的运行 return true; } //拦截之后触发 @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(\u0026#34;postHandle\u0026#34;); HandlerInterceptor.super.postHandle(request, response, handler, modelAndView); } //拦截完成后触发 @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(\u0026#34;afterCompletion\u0026#34;); HandlerInterceptor.super.afterCompletion(request, response, handler, ex); } } 定义配置类, 继承WebMvcConfigurationSupport实现addInterceptors()方法 或者 在SpringMvcConfig里实现WebMvcConfigurer接口\n继承WebMvcConfigurationSupport的方式\n@Configuration public class SpringMVCSupport extends WebMvcConfigurationSupport { @Autowired private UserInterceptor userInterceptor; //静态资源过滤 @Override protected void addResourceHandlers(ResourceHandlerRegistry registry) { //当访问/pages/xxx时,走/pages目录里的内容 registry.addResourceHandler(\u0026#34;/pages/**\u0026#34;).addResourceLocations(\u0026#34;/pages/\u0026#34;); } //注册拦截器 @Override protected void addInterceptors(InterceptorRegistry registry) { //访问 /users 时拦截 registry.addInterceptor(userInterceptor1).addPathPatterns(\u0026#34;/users\u0026#34;,\u0026#34;/users/*\u0026#34;); //如果有多个拦截器,只要这边再次添加即可 registry.addInterceptor(userInterceptor2).addPathPatterns(\u0026#34;/users\u0026#34;,\u0026#34;/users/*\u0026#34;); registry.addInterceptor(userInterceptor3).addPathPatterns(\u0026#34;/users\u0026#34;,\u0026#34;/users/*\u0026#34;); registry.addInterceptor(userInterceptor4).addPathPatterns(\u0026#34;/users\u0026#34;,\u0026#34;/users/*\u0026#34;); //上述拦截器执行顺序 1 -\u0026gt; 2 -\u0026gt; 3 -\u0026gt; 4 与你的代码书写顺序挂钩, 如果上面代码里 userInterceptor4写在userInterceptor3前面那执行顺序就变成了 1 -\u0026gt; 2 -\u0026gt; 4 -\u0026gt; 3 //上方多个拦截器的执行顺序根据你上面书写的顺序有关. 且拦截器里的三个方法遵循先进后出,后进先出的规则, 与Servlet的过滤器一致 } } 实现WebMvcConfigurer接口的方式(此方法侵入式较强, 与Spring绑定)\n@Configuration @ComponentScan({\u0026#34;com.eoezora.controller\u0026#34;, \u0026#34;com.eoezora.exception\u0026#34;, \u0026#34;com.eoezora.interceptor\u0026#34;}) @EnableWebMvc public class SpringMVCConfig implements WebMvcConfigurer { @Autowired private UserInterceptor userInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(userInterceptor).addPathPatterns(\u0026#34;/users\u0026#34;, \u0026#34;/users/*\u0026#34;); } @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { registry.addResourceHandler(\u0026#34;/pages/**\u0026#34;).addResourceLocations(\u0026#34;/pages/\u0026#34;); } } 两者方式都一样, 只是写的地方不同而已\n拦截器参数 处理器: @Controller里的方法\nboolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n返回值: 当返回值为false时, 被拦截的处理器将不再执行 postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)\nModelAndView modelAndView: 如果处理器执行完成后有返回结果, 可以根据modelAndView读取对应数据与页面信息,并进行调整 afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)\nException ex: 如果处理器遇到异常,可以针对异常进行处理 这个三个方法共有的参数\nHttpServletRequest request: 请求对象, 可以根据这个获取该次请求的请求数据 HttpServletResponse response: 响应对象，可以根据这个获取该次请求的响应数据 Object handler: 被调用的处理器对象,本质是一个方法, 对反射技术中的Method进行封装 ","permalink":"https://watson-cat.github.io/posts/spring/spring-%E6%8B%A6%E6%88%AA%E5%99%A8/","summary":"入门案例 定义一个拦截器Bean,实现HandlerInterceptor接口\n@Component public class UserInterceptor implements HandlerInterceptor { //拦截之前触发 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(\u0026#34;preHandle\u0026#34;); //返回false表示不放行 中止原始操作, 也会影响拦截器链的运行 return true; } //拦截之后触发 @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(\u0026#34;postHandle\u0026#34;); HandlerInterceptor.super.postHandle(request, response, handler, modelAndView); } //拦截完成后触发 @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(\u0026#34;afterCompletion\u0026#34;); HandlerInterceptor.super.afterCompletion(request, response, handler, ex); } } 定义配置类, 继承WebMvcConfigurationSupport实现addInterceptors()方法 或者 在SpringMvcConfig里实现WebMvcConfigurer接口","title":"JavaWEB笔记-Spring拦截器"},{"content":"Maven坐标 \u0026lt;!--德鲁伊连接池--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;druid\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.13-SNSAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--数据库连接组件--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--mybatis--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.11\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--spring操作数据库需要的--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-jdbc\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--spring整合mybatis需要的--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-spring\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.7\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; JDBC配置类 public class JDBCConfig { @Value(\u0026#34;${jdbc.url}\u0026#34;) private String url; @Value(\u0026#34;${jdbc.username}\u0026#34;) private String username; @Value(\u0026#34;${jdbc.password}\u0026#34;) private String password; private String driverClass = \u0026#34;com.mysql.jdbc.Driver\u0026#34;; @Bean public DataSource dataSource() { DruidDataSource druidDataSource = new DruidDataSource(); druidDataSource.setDriverClassName(driverClass); druidDataSource.setUrl(url); druidDataSource.setUsername(username); druidDataSource.setPassword(password); return druidDataSource; } } Mybatis配置类 public class MybatisConfig { @Bean public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource) { //创建SqlSessionFactoryBean SqlSessionFactoryBean sfb = new SqlSessionFactoryBean(); //设置mybatis别名扫描 sfb.setTypeAliasesPackage(\u0026#34;com.eoezora.spring_mybatis.domain\u0026#34;); //设置数据源 sfb.setDataSource(dataSource); return sfb; } @Bean public MapperScannerConfigurer mapperScannerConfigurer() { //创建映射文件配置MapperScannerConfigurer MapperScannerConfigurer msc = new MapperScannerConfigurer(); //设置映射文件所在的包路径 msc.setBasePackage(\u0026#34;com.eoezora.spring_mybatis.dao\u0026#34;); return msc; } } Spring配置类 @Configuration @ComponentScan(\u0026#34;com.eoezora.spring_mybatis\u0026#34;) @PropertySource(\u0026#34;classpath:jdbc.properties\u0026#34;) @Import({MybatisConfig.class, JDBCConfig.class}) public class SpringConfig { } 至此Spring和Mybatis整和完毕\n","permalink":"https://watson-cat.github.io/posts/spring/spring-%E6%95%B4%E5%90%88mybatis/","summary":"Maven坐标 \u0026lt;!--德鲁伊连接池--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;druid\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.13-SNSAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--数据库连接组件--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--mybatis--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.11\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--spring操作数据库需要的--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-jdbc\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--spring整合mybatis需要的--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-spring\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.7\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; JDBC配置类 public class JDBCConfig { @Value(\u0026#34;${jdbc.url}\u0026#34;) private String url; @Value(\u0026#34;${jdbc.username}\u0026#34;) private String username; @Value(\u0026#34;${jdbc.password}\u0026#34;) private String password; private String driverClass = \u0026#34;com.mysql.jdbc.Driver\u0026#34;; @Bean public DataSource dataSource() { DruidDataSource druidDataSource = new DruidDataSource(); druidDataSource.setDriverClassName(driverClass); druidDataSource.setUrl(url); druidDataSource.setUsername(username); druidDataSource.setPassword(password); return druidDataSource; } } Mybatis配置类 public class MybatisConfig { @Bean public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource) { //创建SqlSessionFactoryBean SqlSessionFactoryBean sfb = new SqlSessionFactoryBean(); //设置mybatis别名扫描 sfb.","title":"JavaWEB笔记-Spring整合mybatis"},{"content":"简介 AOP: 面向切面编程, 一种编程范式,指导开发者如何组织程序结构\n作用: 在不惊动原始设计的基础上进行功能增强\nSpring理念: 无入侵式\\无侵入式 编程\n代理(Proxy): 本质是采用代理模式实现\n切入点(PointCut): 匹配连接点的式子, 可以理解成共性功能的方法描述\n连接点(JoinPoint): 可以被增强的方法, 可以理解成任意方法\n通知(Advice): 要添加的功能, 共性功能,\n切面(Aspect): 把通知应用到切入点的过程\n目标对象(Target): 被代理的原始对象的目标对象\n简单例子 Spring自带aop相关依赖,这里只需要导入Aspectj即可\n导入Maven坐标 \u0026lt;!--aspectj坐标--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.aspectj\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aspectjweaver\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.9.9.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 通知类 /** * 通知类 * @Aspect 告诉Spring这是个AOP增强 */ @Component @Aspect public class AOPAdvice { /** * 定义一个 \u0026lt;切入点\u0026gt; * @Pointcut 切入点注解 * \u0026#34;execution(void com.eoezora.aop_spring.dao.BookDao.update())\u0026#34; 执行目标包下的某个方法 */ @Pointcut(\u0026#34;execution(void com.eoezora.aop_spring.dao.BookDao.update())\u0026#34;) private void commonUpdate() {} /** * 定义一个 \u0026lt;通知\u0026gt; 方法 * @Before 在方法执行前通知 * @After 在方法执行后通知 * @AfterReturning 放回后通知 * @AfterThrowing 发生异常后通知 * @Around 在方法执行前和执行后通知 */ @Before(\u0026#34;commonUpdate()\u0026#34;) public void commonMethod() { System.out.println(\u0026#34;Now: \u0026#34; + System.currentTimeMillis()); } //环绕方法的使用， 因为无法预测原始方法是否会出异常, 所以这里需要把他抛出去 //获取原始方法相关签名信息 使用point.getSignature(); 可以获取原始代码的类名, 增强的方法名等 @Around(\u0026#34;commonSelect()\u0026#34;) public Object commonMethod(ProceedingJoinPoint point) throws Throwable { System.out.println(\u0026#34;A: \u0026#34; + System.currentTimeMillis()); //原始方法的调用并获取原始方法执行后的的返回值 Object ret = point.proceed(); System.out.println(\u0026#34;B: \u0026#34; + System.currentTimeMillis()); //返回原始方法执行后的返回值 return ret; } } 接口实现类 @Repository public class BookDaoImpl implements BookDao { @Override public void save() { System.out.println(System.currentTimeMillis()); System.out.println(\u0026#34;book save...\u0026#34;); } //\u0026lt;连接点\u0026gt; 方法 @Override public void update() { System.out.println(\u0026#34;book update...\u0026#34;); } @Override public void select() { System.out.println(\u0026#34;book select...\u0026#34;); } } Spring配置类 @Configuration @ComponentScan(\u0026#34;com.eoezora\u0026#34;) @PropertySource(\u0026#34;classpath:jdbc.properties\u0026#34;) //开启aop自动代理 @EnableAspectJAutoProxy public class SpringConfig { } 工作流程 Spring容器启动 读取所有切面配置中的切入点 初始化Bean, 判定Bean对应类中的方法是否匹配到任意切入点 匹配失败: 创建对象 匹配成功: 创建原始对象的代理对象 获取Bean执行方法 获取Bean, 调用方法并执行 获取的Bean是代理对象,根据代理对象的运行模式运行原始方法与增强内容 整个实现过程使用代理模式实现\n切入点表达式 切入点表达式标准格式: 动作关键字(访问修饰符 返回值 包名.类/接口名.方法名(参数) 异常名)\n可以使用通配符描述切入点,快速描述,例如\n//匹配 com.eoezora包下的任意包中的BookDao类或接口中update开头的带头一个任意参数的方法 execution(public * com.eoezora.*.BookDao.update*(*)) //匹配com包下的任意包中的BookDao类或接口中所有update方法 execution(public BookDao com..BookDao.update(..)) // + 用于匹配子类类型, 任意返回值,任意包下的以BookDao结尾的类或接口的子类中的任意方法 execution(* *..*BookDao+.(..)) 获取通知数据 获取参数 JoinPoint: 适用于前置, 后置 返回后, 抛出异常后通知\nProceedJoinPoint: 适用于环绕通知\n获取返回值 返回后通知\n/** * 此方法里带参数,有JoinPoint的话,始终保持第一个参数, 后面接返回的 * returning = \u0026#34;ret\u0026#34; ret是该方法的参数, 也是@AfterReturning返回的原始方法的返回值 */ @AfterReturning(value = \u0026#34;commonTest()\u0026#34;, returning = \u0026#34;ret\u0026#34;) public Object commonMethod(JoinPoint point, Object ret) throws Throwable { return ret; } 环绕通知\n/** * 环绕方法执行原型方法后会返回原始方法的返回值 */ @Around(\u0026#34;commonTest()\u0026#34;) public Object commonMethod(ProceedingJoinPoint point) throws Throwable { //如果原始方法返回100, 则ret就是100 Object ret = point.proceed(); return ret; } 获取异常 抛出异常后通知\n/** * 抛出异常后返回 \u0026#34;异常\u0026#34; */ @AfterThrowing(value = \u0026#34;commonTest()\u0026#34;, throwing = \u0026#34;t\u0026#34;) public void commonMethod(Throwable t) throws Throwable { } 环绕通知\n","permalink":"https://watson-cat.github.io/posts/spring/spring-aop%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/","summary":"简介 AOP: 面向切面编程, 一种编程范式,指导开发者如何组织程序结构\n作用: 在不惊动原始设计的基础上进行功能增强\nSpring理念: 无入侵式\\无侵入式 编程\n代理(Proxy): 本质是采用代理模式实现\n切入点(PointCut): 匹配连接点的式子, 可以理解成共性功能的方法描述\n连接点(JoinPoint): 可以被增强的方法, 可以理解成任意方法\n通知(Advice): 要添加的功能, 共性功能,\n切面(Aspect): 把通知应用到切入点的过程\n目标对象(Target): 被代理的原始对象的目标对象\n简单例子 Spring自带aop相关依赖,这里只需要导入Aspectj即可\n导入Maven坐标 \u0026lt;!--aspectj坐标--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.aspectj\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aspectjweaver\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.9.9.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 通知类 /** * 通知类 * @Aspect 告诉Spring这是个AOP增强 */ @Component @Aspect public class AOPAdvice { /** * 定义一个 \u0026lt;切入点\u0026gt; * @Pointcut 切入点注解 * \u0026#34;execution(void com.eoezora.aop_spring.dao.BookDao.update())\u0026#34; 执行目标包下的某个方法 */ @Pointcut(\u0026#34;execution(void com.eoezora.aop_spring.dao.BookDao.update())\u0026#34;) private void commonUpdate() {} /** * 定义一个 \u0026lt;通知\u0026gt; 方法 * @Before 在方法执行前通知 * @After 在方法执行后通知 * @AfterReturning 放回后通知 * @AfterThrowing 发生异常后通知 * @Around 在方法执行前和执行后通知 */ @Before(\u0026#34;commonUpdate()\u0026#34;) public void commonMethod() { System.","title":"JavaWEB笔记-Spring-AOP"},{"content":"控制反转Ioc 使用对象时,由主动new产生对象转换为由外部提供对象, 此过程中创建对象控制权由程序转移到外部,此思想称为控制反转\nSpring对Ioc思想的实现\nSpring提供了一个容器,称为Ioc容器，用来充当Ioc思想中的\u0026quot;外部\u0026quot; Ioc容器负责对象创建,初始化等一系工作, 被创建或被管理的对象在Ioc容器中被称为Bean DI(Dependency Injection): 依赖注入\n在容器中建立的Bean与Bean之间的依赖关系的整个过程,称为依赖注入 目标: 充分解耦\n使用Ioc容器管理Bean 在Ioc容器内将有依赖关系的Bean进行关系绑定(DI) 适合给容器管理的Bean\n表现层对象 业务层对象 数据层对象 工具对象 不适合给容器管理的Bean\n封装实体的域对象 xml配置Bean 一个Bean配置文件\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;!--id为Bean名字--\u0026gt; \u0026lt;!--name 为bean起别名--\u0026gt; \u0026lt;!--Class是bean接口对应实现类--\u0026gt; \u0026lt;!--scope时bean的作用范围,默认singleton单例 | prototype非单例 --\u0026gt; \u0026lt;bean id=\u0026#34;bookInfo\u0026#34; class=\u0026#34;com.eoezora.springdemo.dao.impl.PysBookImpl\u0026#34;/\u0026gt; \u0026lt;!--id为Bean名字 Class是bean接口对应实现类--\u0026gt; \u0026lt;bean id=\u0026#34;bookService\u0026#34; class=\u0026#34;com.eoezora.springdemo.services.impl.BookServerImpl\u0026#34;\u0026gt; \u0026lt;!--配置当前Bean的属性--\u0026gt; \u0026lt;!--name属性表示配置哪一个属性--\u0026gt; \u0026lt;!--ref表示参照哪个Bean--\u0026gt; \u0026lt;property name=\u0026#34;bookInfo\u0026#34; ref=\u0026#34;bookInfo\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; Java使用代码\npublic static void main(String[] args) { //根据配置文件获取IoC容器 ApplicationContext ctx = new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); //ctx.getBean(bean的id); BookService bookService = (BookService) ctx.getBean(\u0026#34;bookService\u0026#34;); bookService.addBook(1, \u0026#34;weee\u0026#34;); bookService.getBook(); } 业务层例子\npackage com.eoezora.springdemo.services.impl; import com.eoezora.springdemo.dao.BookInfo; import com.eoezora.springdemo.services.BookService; public class BookServerImpl implements BookService { //使用DI依赖注入时, 业务层Service中使用new的方式创建的对象要删除 //在xml配置DI注入，运行后容器会帮我们自动 BookInfo bookInfo; @Override public BookInfo getBook() { System.out.println(\u0026#34;return a book...\u0026#34;); return null; } @Override public void addBook(int id, String bName) { bookInfo.save(); System.out.println(\u0026#34;add a book -\u0026gt; \u0026#34; + id + \u0026#34; - \u0026#34; + bName); } //Set方法, IoC供容器调用赋值 public void setBookInfo(BookInfo bookInfo) { this.bookInfo = bookInfo; } } 加载properties文件 在applicationContext.xml里开辟一块新的命名空间\n\u0026lt;!-- 新增下面这三行 --\u0026gt; \u0026lt;!--xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34;--\u0026gt; \u0026lt;!--http://www.springframework.org/schema/context--\u0026gt; \u0026lt;!--http://www.springframework.org/schema/context/spring-context.xsd--\u0026gt; \u0026lt;!-- 下面是新增好的 --\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd \u0026#34;\u0026gt; \u0026lt;!--新增一个property占位符, location是要加载的proper文件路径--\u0026gt; \u0026lt;context:property-placeholder location=\u0026#34;bookInfo.properties\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;bookService\u0026#34; scope=\u0026#34;prototype\u0026#34; class=\u0026#34;com.eoezora.springdemo.services.impl.BookServerImpl\u0026#34;\u0026gt; \u0026lt;!--配置当前Bean的属性--\u0026gt; \u0026lt;!--name属性表示配置哪一个属性--\u0026gt; \u0026lt;!--ref表示参照哪个Bean--\u0026gt; \u0026lt;property name=\u0026#34;bookInfo\u0026#34; ref=\u0026#34;bookInfo\u0026#34;/\u0026gt; \u0026lt;!-- 配置完成后就可以使用${key} 的形式读取目标proper文件的内容 --\u0026gt; \u0026lt;bean id=\u0026#34;bookService\u0026#34; scope=\u0026#34;prototype\u0026#34; class=\u0026#34;com.eoezora.springdemo.services.impl.BookServerImpl\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;bookInfo\u0026#34; ref=\u0026#34;bookInfo\u0026#34; value=\u0026#34;${book.name}\u0026#34;/\u0026gt; \u0026lt;!-- 假设 bookInfo.properties如下 --\u0026gt; \u0026lt;!-- book.name=kafka的城堡 --\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 注解开发 Spring3.0后使用纯注解开发,使用**@Configuration**代替了xml配置文件.\n//在实现类上添加注解@Component来定义一个Bean @Component @Component(\u0026#34;bean名字\u0026#34;) public class demo implements someInterface { } //定义一个配置类 @Configuration //设置bean扫描包路径 @ComponentScan(\u0026#34;com.eoezora.spring_ano\u0026#34;) //加载外部配置文件 @PropertySource(\u0026#34;jdbc.properties\u0026#34;) public class SpringConfig { } public static void main(String[] args) { //使用AnnotationConfigApplicationContext加载配置类获取容器 ApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class); IServices services = context.getBean(IServices.class); services.printData(); } 作用范围|生命周期 作用范围: 在接口实现类添加注解 @Scope() 参考xml配置的scope属性\n@Scope(\u0026#34;prototype\u0026#34;) public class CommonServiceImpl implements CommonServices{} Bean的生命周期注解\n//标注在方法上,表示该方法是Bean的初始化方法 @PostConstruct //标注在方法上,表示该方法是Bean的销毁方法 @PreDestroy public void printData() { System.out.println(commonDao.getData()); } 自动装配 //使用注解@Autowired实现自动装配, 按类型来 @Autowired //当有多个同一接口的实现类时,使用@Qualifier实现指定装配 @Qualifier(\u0026#34;bean的名字\u0026#34;) private CommonDao commonDao; /** * @Value装备基本数据类型 * 可以把配置文件里的数值装配到该变量 * 假设在配置文件类里使用了 @PropertySource(\u0026#34;jdbc.properties\u0026#34;) 加载了jdbc配置 * 可以使用 ${key-name} 的形式获取数据 * jdbc.url=http://localhost:3306/eoezora **/ @Value(\u0026#34;${jdbc.url}\u0026#34;) private String url; 注解管理第三方Bean\n//添加@Bean注解表示该方法返回值是一个Bean @Bean public DataSource dataSource() { DruidDataSource ds = new DruidDataSource(); ds.setXXXX(); return ds; } /** * 第三方Bean的依赖注入 * 添加@Bean注解表示该方法返回值是一个Bean * 如果要给第三方的Bean依赖注入,用形参的形式给到对应方法里 * spring会从容器里找到该形参的Bean然后传到指定方法 * 以下方方法为例, 我要传入数据库配置信息获得Druid连接池 * 我定义一个SqlConfig存放数据库信息 * 然后给到dataSource()方法 * Spring会自动帮我们装配参数 */ @Bean public DataSource dataSource(SqlConfig sc) { //bd do something... DruidDataSource ds = new DruidDataSource(); ds.setUrl(sc.getUrl()); return ds; } ","permalink":"https://watson-cat.github.io/posts/spring/spring-ioc%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/","summary":"控制反转Ioc 使用对象时,由主动new产生对象转换为由外部提供对象, 此过程中创建对象控制权由程序转移到外部,此思想称为控制反转\nSpring对Ioc思想的实现\nSpring提供了一个容器,称为Ioc容器，用来充当Ioc思想中的\u0026quot;外部\u0026quot; Ioc容器负责对象创建,初始化等一系工作, 被创建或被管理的对象在Ioc容器中被称为Bean DI(Dependency Injection): 依赖注入\n在容器中建立的Bean与Bean之间的依赖关系的整个过程,称为依赖注入 目标: 充分解耦\n使用Ioc容器管理Bean 在Ioc容器内将有依赖关系的Bean进行关系绑定(DI) 适合给容器管理的Bean\n表现层对象 业务层对象 数据层对象 工具对象 不适合给容器管理的Bean\n封装实体的域对象 xml配置Bean 一个Bean配置文件\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;!--id为Bean名字--\u0026gt; \u0026lt;!--name 为bean起别名--\u0026gt; \u0026lt;!--Class是bean接口对应实现类--\u0026gt; \u0026lt;!--scope时bean的作用范围,默认singleton单例 | prototype非单例 --\u0026gt; \u0026lt;bean id=\u0026#34;bookInfo\u0026#34; class=\u0026#34;com.eoezora.springdemo.dao.impl.PysBookImpl\u0026#34;/\u0026gt; \u0026lt;!--id为Bean名字 Class是bean接口对应实现类--\u0026gt; \u0026lt;bean id=\u0026#34;bookService\u0026#34; class=\u0026#34;com.eoezora.springdemo.services.impl.BookServerImpl\u0026#34;\u0026gt; \u0026lt;!--配置当前Bean的属性--\u0026gt; \u0026lt;!--name属性表示配置哪一个属性--\u0026gt; \u0026lt;!--ref表示参照哪个Bean--\u0026gt; \u0026lt;property name=\u0026#34;bookInfo\u0026#34; ref=\u0026#34;bookInfo\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; Java使用代码\npublic static void main(String[] args) { //根据配置文件获取IoC容器 ApplicationContext ctx = new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); //ctx.getBean(bean的id); BookService bookService = (BookService) ctx.","title":"JavaWEB笔记-Spring核心容器"},{"content":"会话 会话:客户端跟服务端的连接,会话建立后直到一方断开连接才会结束.在一次会话中可以包含多次请求和响应 会话跟踪:服务端会识别多个请求是否来自同一个客户端,以便在同次会话的多次请求间共享数据 HTTP协议是无状态的,每次客户端向服务端请求时。服务端都会将该请求视为新的请求,因此我们需要会话跟踪技术来实现会话内数据共享 实现方式: 客户端会话跟踪技术: Cookie 服务端跟会话踪技术: Session Cokkie 客户端会话技术,将数据保存在客户端,以后每次请求都携带Cookie数据进行访问\n基本使用 @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //创建Cookie对象 Cookie cookie = new Cookie(\u0026#34;key\u0026#34;,\u0026#34;value\u0026#34;); //发送cookie到客户端 response.addCookie(cookie); //获取客户端所有cookie Cookie[] cookies = request.getCookies(); //通过遍历获取每个cookie for (Cookie cookie1 : cookies) { System.out.println(cookie1.getName() + \u0026#34; - \u0026#34; + cookie1.getValue()); } } 存活时间 默认情况下, 当浏览器关闭后,内存释放,Cookie会被销毁\n使用方法 cookie.setMaxAge(秒) 设置cookie存活时间\n而参数有以下含义\n正数: 将会cookie写入浏览器所在电脑硬盘,持久化存储到期自动删除 负数: 默认值, Cookie存在于浏览器内存中,浏览器关闭自动销毁 零: 删除对应cookie 存储中文 Cookie不支持存中文, 如果非要存中文可以把中文进行URL编码存进去, 取的时候再解码\nSession 客户端会话技术,基于Cookie实现, 将数据保存在服务端, JavaEE提供了HttpSession接口来实现一次会话多次请求间数据的共享功能\n基本使用 //获取Session对象 HttpSession hs = request.getSession(); //设置session值, 键值对 hs.setAttribute(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;); //根据key获取Session的值 String v = (String) hs.getAttribute(\u0026#34;key\u0026#34;); 钝化 服务端正常关闭后,Tomcat会自动将Session数据写入到硬盘文件中\n活化 服务器启动后,会从文件中加载Session\n销毁 在web.xml配置Session到期时间, 添加下面代码,时间单位: 分钟 \u0026lt;session-config\u0026gt; \u0026lt;session-timeout\u0026gt;30\u0026lt;/session-timeout\u0026gt; \u0026lt;/session-config\u0026gt; 调用Session的 invalidate() 方法销毁 总结 cookie和session都是来完成一次会话多次请求之间的数据共享\n区别：\n存储位置: cookie存储在客户端, session存储在服务端 安全性: cookie不安全, session安全 数据大小: cookie最多3kb, session无大小限制 存储时间: cookie可以无限期存储, session默认30分钟 性能影响: cookie不占用服务器资源, session占用服务器资源 ","permalink":"https://watson-cat.github.io/posts/javaweb/javaweb-%E4%BC%9A%E8%AF%9D%E8%B7%9F%E8%B8%AA%E6%8A%80%E6%9C%AF/","summary":"会话 会话:客户端跟服务端的连接,会话建立后直到一方断开连接才会结束.在一次会话中可以包含多次请求和响应 会话跟踪:服务端会识别多个请求是否来自同一个客户端,以便在同次会话的多次请求间共享数据 HTTP协议是无状态的,每次客户端向服务端请求时。服务端都会将该请求视为新的请求,因此我们需要会话跟踪技术来实现会话内数据共享 实现方式: 客户端会话跟踪技术: Cookie 服务端跟会话踪技术: Session Cokkie 客户端会话技术,将数据保存在客户端,以后每次请求都携带Cookie数据进行访问\n基本使用 @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //创建Cookie对象 Cookie cookie = new Cookie(\u0026#34;key\u0026#34;,\u0026#34;value\u0026#34;); //发送cookie到客户端 response.addCookie(cookie); //获取客户端所有cookie Cookie[] cookies = request.getCookies(); //通过遍历获取每个cookie for (Cookie cookie1 : cookies) { System.out.println(cookie1.getName() + \u0026#34; - \u0026#34; + cookie1.getValue()); } } 存活时间 默认情况下, 当浏览器关闭后,内存释放,Cookie会被销毁\n使用方法 cookie.setMaxAge(秒) 设置cookie存活时间\n而参数有以下含义\n正数: 将会cookie写入浏览器所在电脑硬盘,持久化存储到期自动删除 负数: 默认值, Cookie存在于浏览器内存中,浏览器关闭自动销毁 零: 删除对应cookie 存储中文 Cookie不支持存中文, 如果非要存中文可以把中文进行URL编码存进去, 取的时候再解码","title":"JavaWEB笔记-会话跟踪技术"},{"content":"请求的数据格式 数据分为三部分\n请求行: 请求数据第一行, GET/POST 表示请求方式 / 表示请求路径 HTTP/1.1表示协议版本 请求头: 键值对数据 请求体: POST请求的最后一部分, 存放请求参数 例子:\nGET / HTTP/1.1 浏览器能够接受的资源类型 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 浏览器可以支持的压缩类型 Accept-Encoding: gzip, deflate, br 浏览器偏好语言 Accept-Language: en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7 Cache-Control: max-age=0 Connection: keep-alive Cookie: 请求主机名 Host: www.baidu.com Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: none Sec-Fetch-User: ?1 Upgrade-Insecure-Requests: 1 浏览器版本 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36 sec-ch-ua: \u0026#34;Chromium\u0026#34;;v=\u0026#34;106\u0026#34;, \u0026#34;Google Chrome\u0026#34;;v=\u0026#34;106\u0026#34;, \u0026#34;Not;A=Brand\u0026#34;;v=\u0026#34;99\u0026#34; sec-ch-ua-mobile: ?0 sec-ch-ua-platform: \u0026#34;Windows\u0026#34; GET请求参数在请求行中.没有请求体\nPOST请求参数在请求体中\nGET请求有参数大小限制.POST没有\n响应的数据格式 数据分为三部分\n响应行: 响应数据第一行, HTTP/1.1表示协议版本 200 代表响应代码 OK 表示状态描述 响应头: 键值对数据 响应体: 最后一部分, 存放响应数据 HTTP/1.1 200 OK Bdpagetype: 2 Bdqid: 0xeaa6d46b0000e982 客户端如何缓存, 设置 max-age=300 表示最多缓存300秒 Cache-Control: private Connection: keep-alive 响应的压缩算法 Content-Encoding: gzip 响应内容的类型 Content-Type: text/html;charset=utf-8 响应内容长度(字节数) Content-Lenght: 100 Server: BWS/1.1 Set-Cookie: BDSVRTM=318; path=/ Set-Cookie: BD_HOME=1; path=/ Set-Cookie: H_PS_PSSID=37375_36551_37359_36884_37402_37396_37406_36786_37499_26350_37448_37370_37449; path=/; domain=.baidu.com Strict-Transport-Security: max-age=172800 Traceid: 1665032548061897473016908435407035754882 X-Frame-Options: sameorigin X-Ua-Compatible: IE=Edge,chrome=1 Transfer-Encoding: chunked ","permalink":"https://watson-cat.github.io/posts/javaweb/javaweb-http/","summary":"请求的数据格式 数据分为三部分\n请求行: 请求数据第一行, GET/POST 表示请求方式 / 表示请求路径 HTTP/1.1表示协议版本 请求头: 键值对数据 请求体: POST请求的最后一部分, 存放请求参数 例子:\nGET / HTTP/1.1 浏览器能够接受的资源类型 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 浏览器可以支持的压缩类型 Accept-Encoding: gzip, deflate, br 浏览器偏好语言 Accept-Language: en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7 Cache-Control: max-age=0 Connection: keep-alive Cookie: 请求主机名 Host: www.baidu.com Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: none Sec-Fetch-User: ?1 Upgrade-Insecure-Requests: 1 浏览器版本 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36 sec-ch-ua: \u0026#34;Chromium\u0026#34;;v=\u0026#34;106\u0026#34;, \u0026#34;Google Chrome\u0026#34;;v=\u0026#34;106\u0026#34;, \u0026#34;Not;A=Brand\u0026#34;;v=\u0026#34;99\u0026#34; sec-ch-ua-mobile: ?0 sec-ch-ua-platform: \u0026#34;Windows\u0026#34; GET请求参数在请求行中.","title":"JavaWEB笔记-HTTP"},{"content":"快速入门 创建web项目,导入servlet坐标\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javax.servlet-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.0.1\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Tomcat 10 使用这个--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;jakarta.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jakarta.servlet-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.0.0\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; 简单使用例\npackage com.eoezora.controller; import jakarta.servlet.ServletException; import jakarta.servlet.annotation.WebServlet; import jakarta.servlet.http.HttpServlet; import jakarta.servlet.http.HttpServletRequest; import jakarta.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(\u0026#34;/test\u0026#34;) // 访问路径是 /test public class TestController extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\u0026#34;get\u0026#34;); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\u0026#34;post\u0026#34;); } } urlPattern配置 Servlet想要被访问,就必须设置其访问路径 (urlPattern)\n一个Servlet可以配置多个urlPattern, 例如 @WebServlet(urlPattern = {\u0026quot;/test1\u0026quot;, \u0026ldquo;/test2\u0026rdquo;, \u0026ldquo;/test3\u0026rdquo;})\nurlPattern配置规则\n优先级: 精确路径匹配 \u0026gt; 目录路径匹配 \u0026gt; 扩展名匹配 \u0026gt; / /*\n精确匹配 @WebServlet(\u0026#34;/user/info\u0026#34;) //访问路径为 -\u0026gt; http://localhost:8080/webapp/user/info 目录匹配 以下面例子来说,只要在/user目录下的请求都能访问该Servlet\n@WebServlet(\u0026#34;/user/*\u0026#34;) //访问路径为 -\u0026gt; http://localhost:8080/webapp/user/aaa | http://localhost:8080/webapp/user/bbb 拓展名匹配 访问该拓展名的文件资源\n@WebServlet(\u0026#34;*.do\u0026#34;) //访问路径为 -\u0026gt; http://localhost:8080/webapp/aaa.do 任意匹配 不管访问地址是啥，都能访问这个Servlet\n@WebServlet(\u0026#34;/\u0026#34;) @WebServlet(\u0026#34;/*\u0026#34;) //访问路径为 -\u0026gt; http://localhost:8080/webapp/abc 可以用任意路径访问这个Servlet //当我们在项目中设置了 \u0026#34;/\u0026#34; 和 \u0026#34;/*\u0026#34; 后会覆盖掉tomcat默认的DefaultServlet.当其他的urlPattern都匹配不上时会访问这个Servlet xml配置Servlet 需要在web.xml中配置, 例子如下, Servlet类与注解方式一样，只是不需要写注解@WebServlet\n\u0026lt;servlet\u0026gt; \u0026lt;!-- servlet名字 --\u0026gt; \u0026lt;servlet-name\u0026gt;test\u0026lt;/servlet-name\u0026gt; \u0026lt;!-- servlet类的路径 --\u0026gt; \u0026lt;servlet-class\u0026gt;com.eoezora.controller.TestController\u0026lt;/servlet-class\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;!-- servlet名字 --\u0026gt; \u0026lt;servlet-name\u0026gt;test\u0026lt;/servlet-name\u0026gt; \u0026lt;!-- servlet访问路径 --\u0026gt; \u0026lt;url-pattern\u0026gt;/test\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; ","permalink":"https://watson-cat.github.io/posts/javaweb/javaweb-tomcat/","summary":"快速入门 创建web项目,导入servlet坐标\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javax.servlet-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.0.1\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Tomcat 10 使用这个--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;jakarta.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jakarta.servlet-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.0.0\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; 简单使用例\npackage com.eoezora.controller; import jakarta.servlet.ServletException; import jakarta.servlet.annotation.WebServlet; import jakarta.servlet.http.HttpServlet; import jakarta.servlet.http.HttpServletRequest; import jakarta.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(\u0026#34;/test\u0026#34;) // 访问路径是 /test public class TestController extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\u0026#34;get\u0026#34;); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\u0026#34;post\u0026#34;); } } urlPattern配置 Servlet想要被访问,就必须设置其访问路径 (urlPattern)","title":"JavaWEB笔记-Servlet"},{"content":"概念 Filter过滤器,是JavaWeb三大组件之一(Servlet, Filter, Listener) 过滤器可以把资源拦截下来,从而实现一些需求 过滤器一般完成一些通用操作,如访问权限控制, 统一编码处理, 铭感字符处理等 快速入门 定义类,实现Filter接口，重写所有方法\npublic class FilterDemo implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { Filter.super.init(filterConfig); } @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { } @Override public void destroy() { Filter.super.destroy(); } } 配置Filter拦截路径, 使用@WebFilter注解\n@WebFilter(\u0026#34;/*\u0026#34;) //表示拦截所有访问 public class FilterDemo implements Filter { } 放行\n@Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { //放行前逻辑 //对request进行处理 //放行请求 chain.doFilter(request,response); //放行后逻辑 //对response进行处理 } 过滤器执行过程 过滤器拦截 -\u0026gt; 执行放行前逻辑 -\u0026gt; 放行 -\u0026gt; 访问资源 -\u0026gt; 回到过滤器 -\u0026gt; 执行放行后逻辑\n使用细节 拦截路径配置 拦截具体资源: /index.html 只有访问/index.html才会拦截 目录拦截: /user/* 访问/user目录下的所有资源都会被拦截 后缀名拦截: *.html 访问后缀为html都会被拦截 拦截所有: /* 所有访问都会被拦截 过滤器链 可以配置多个过滤器, 串成一个过滤器链\n执行顺序: 多个过滤器以过滤器类名自然排序, 例如: AFilter1 BFilter3 Filter2\n放行逻辑执行顺序: 如下图所示,请求先从左到右执行放行前逻辑直到访问资源, 再从右到左访问放行后逻辑\n","permalink":"https://watson-cat.github.io/posts/javaweb/javaweb-filter%E8%BF%87%E6%BB%A4%E5%99%A8/","summary":"概念 Filter过滤器,是JavaWeb三大组件之一(Servlet, Filter, Listener) 过滤器可以把资源拦截下来,从而实现一些需求 过滤器一般完成一些通用操作,如访问权限控制, 统一编码处理, 铭感字符处理等 快速入门 定义类,实现Filter接口，重写所有方法\npublic class FilterDemo implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { Filter.super.init(filterConfig); } @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { } @Override public void destroy() { Filter.super.destroy(); } } 配置Filter拦截路径, 使用@WebFilter注解\n@WebFilter(\u0026#34;/*\u0026#34;) //表示拦截所有访问 public class FilterDemo implements Filter { } 放行\n@Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { //放行前逻辑 //对request进行处理 //放行请求 chain.","title":"JavaWEB笔记-过滤器"},{"content":"增删改查例子 AccountMapper.xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;!-- namespace是映射接口的路径 --\u0026gt; \u0026lt;mapper namespace=\u0026#34;com.eoezora.mybatisDemo.mapper.AccountMapper\u0026#34;\u0026gt; \u0026lt;!-- 添加数据, 参数POJO -\u0026gt; EoeAccount --\u0026gt; \u0026lt;!-- 添加这两个 useGeneratedKeys=\u0026#34;true\u0026#34; keyProperty=\u0026#34;id\u0026#34; 属性在insert标签里可以返回主键 --\u0026gt; \u0026lt;insert id=\u0026#34;addAccount\u0026#34; useGeneratedKeys=\u0026#34;true\u0026#34; keyProperty=\u0026#34;id\u0026#34;/\u0026gt; \u0026lt;insert id=\u0026#34;addAccount\u0026#34; \u0026gt; INSERT INTO account (name, age, brithDay, location) \u0026lt;!-- 这里的名字要与POJO类力的变量名一致 --\u0026gt; VALUES (#{name},#{age},#{brithDay},#{location}); \u0026lt;/insert\u0026gt; \u0026lt;!-- 删除一条数据 --\u0026gt; \u0026lt;delete id=\u0026#34;delAccouintById\u0026#34;\u0026gt; DELETE FROM account WHERE id = #{id} \u0026lt;/delete\u0026gt; \u0026lt;!-- 删除多条数据 --\u0026gt; \u0026lt;delete id=\u0026#34;delAccouintByIds\u0026#34;\u0026gt; DELETE FROM account WHERE id in \u0026lt;!-- collection需要遍历的集合 item 集合里的元素 separator 分隔符 open 前缀符 close 后缀符 --\u0026gt; \u0026lt;foreach collection=\u0026#34;ids\u0026#34; item=\u0026#34;id\u0026#34; separator=\u0026#34;,\u0026#34; open=\u0026#34;(\u0026#34; close=\u0026#34;)\u0026#34;\u0026gt; #{id} \u0026lt;/foreach\u0026gt; \u0026lt;/delete\u0026gt; \u0026lt;!-- 查询所以数据 多个条件使用 and 分割 --\u0026gt; \u0026lt;select id=\u0026#34;selectAccounts\u0026#34; resultType=\u0026#34;com.eoezora.mybatisDemo.pojo.EoeAccount\u0026#34;\u0026gt; SELECT * FROM account; \u0026lt;/select\u0026gt; \u0026lt;!-- 根据ID查询数据 --\u0026gt; \u0026lt;select id=\u0026#34;selectAccount\u0026#34; parameterType=\u0026#34;int\u0026#34; resultType=\u0026#34;com.eoezora.mybatisDemo.pojo.EoeAccount\u0026#34;\u0026gt; SELECT * FROM account WHERE id = #{id}; \u0026lt;/select\u0026gt; \u0026lt;!-- 根据ID修改数据 --\u0026gt; \u0026lt;!-- 动态修改参考动态查询 --\u0026gt; \u0026lt;update id=\u0026#34;setAccountAge\u0026#34;\u0026gt; UPDATE account SET age = #{age} WHERE id = #{id} \u0026lt;/update\u0026gt; \u0026lt;/mapper\u0026gt; AccountMapper.class package com.eoezora.mybatisDemo.mapper; import com.eoezora.mybatisDemo.pojo.EoeAccount; import java.util.List; //映射接口, 方法名与上方SQL映射xml里的ID一致 public interface AccountMapper { /** * \u0026lt;insert id=\u0026#34;addAccount\u0026#34; parameterType=\u0026#34;com.eoezora.mybatisDemo.pojo.EoeAccount\u0026#34;\u0026gt; **/ void addAccount(EoeAccount eoeAccount); /** * \u0026lt;select id=\u0026#34;selectAccounts\u0026#34; resultType=\u0026#34;com.eoezora.mybatisDemo.pojo.EoeAccount\u0026#34;\u0026gt; **/ List\u0026lt;EoeAccount\u0026gt; selectAccounts(); /** * \u0026lt;select id=\u0026#34;selectAccount\u0026#34; parameterType=\u0026#34;int\u0026#34; resultType=\u0026#34;com.eoezora.mybatisDemo.pojo.EoeAccount\u0026#34;\u0026gt; **/ EoeAccount selectAccount(@Param(\u0026#34;id\u0026#34;)int id); /** * \u0026lt;delete id=\u0026#34;delAccouintById\u0026#34;\u0026gt; **/ void delAccouintById(@Param(\u0026#34;id\u0026#34;)int id); /** * \u0026lt;delete id=\u0026#34;delAccouintByIds\u0026#34;\u0026gt; 传入数组批量删除多条数据 **/ void delAccouintById(@Param(\u0026#34;ids\u0026#34;) int[] id); //传递参数的三种方式 /** * 多个单独的参数, @Param里的值与xml映射表的占位符一致,也就是与 xml 里的 #{} 里的一致 例如: #{name} **/ List\u0026lt;EoeAccount\u0026gt; selectAccountByCondition(@Param(\u0026#34;name\u0026#34;) String name, @Param(\u0026#34;age\u0026#34;) intn age); /** * 如果参数可以封装在同一个类里,也可以直接传一个对象过来. xml #{} 将使用该对象参数名作为占位符 **/ List\u0026lt;EoeAccount\u0026gt; selectAccountByCondition(EoeAccount account); /** * HashMap key -\u0026gt; value * - 占位符名称 -\u0026gt; 数值 **/ List\u0026lt;EoeAccount\u0026gt; selectAccountByCondition(Map map); /** * 使用注解查询, 一般使用在简单的sql语句上, 复杂的语句还是使用xml映射 **/ @Select(\u0026#34;SELECT * FROM account WHERE id = #{id}\u0026#34;) EoeAccount selectAccount(int id); } 使用接口进行增删改查 try (SqlSession session = sqlSessionFactory.openSession()) { AccountMapper mapper = session.getMapper(AccountMapper.class); mapper.selectAccounts(); mapper.addAccount(); //需要注意的是 mybatis 对数据库进行增删改的操作后需要手动提交 session.commit(); } /** * 获取主键 * 当数据添加完成后, 若insert标签有设置useGeneratedKeys=\u0026#34;true\u0026#34; keyProperty=\u0026#34;id\u0026#34; 属性 * 则可以根据 以下方式获取返回的主键id **/ EoeAccount ea = new EoeAccount(\u0026#34;蔡某\u0026#34;,25,\u0026#34;1919-08-10\u0026#34;,\u0026#34;荔枝星\u0026#34;); mapper.addAccount(ea); System.out.println(ea.getId()); 多条件动态查询 在根据条件查询时,多个条件使用以下方式,传入的条件参数是固定的。比如下面这条是3个.\n\u0026lt;!-- 查询所以数据 多个条件使用 and 分割 --\u0026gt; \u0026lt;select id=\u0026#34;selectAccounts\u0026#34; resultType=\u0026#34;com.eoezora.mybatisDemo.pojo.EoeAccount\u0026#34;\u0026gt; SELECT * FROM account WHERE id = 1 AND name = \u0026#39;xxx\u0026#39; AND AGE = 24; \u0026lt;/select\u0026gt; 有时候我们需要的是模糊查询, 用户给的条件数量是不固定的，有时一个有时三个。我们需要根据传来的条件参数数量来动态调整我们的SQL语句。MyBatis提供了许多标签来支持此功能: if | choose(when, otherwise) | trim(where, set) | foreach\n\u0026lt;select id=\u0026#34;selectAccounts\u0026#34; resultType=\u0026#34;com.eoezora.mybatisDemo.pojo.EoeAccount\u0026#34;\u0026gt; SELECT * FROM account \u0026lt;!-- 使用where标签可以解决第一个条件不存在时的报错, 同时会帮我们去掉多余的AND --\u0026gt; \u0026lt;!-- 下面为例 当id小于0，条件不会被拼到sql语句里,且会帮我们去掉name前面的AND --\u0026gt; \u0026lt;where\u0026gt; \u0026lt;!-- test后面跟判断条件 --\u0026gt; \u0026lt;if test=\u0026#34;id \u0026gt; 0\u0026#34;\u0026gt; AND id = #{id} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;name != null\u0026#34;\u0026gt; AND name LIKE #{name} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;age \u0026gt; 0\u0026#34;\u0026gt; AND age = #{age} \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; 单条件动态查询 当我们需要单条件动态查询时，使用以下方法\n\u0026lt;select id=\u0026#34;selectAccounts\u0026#34; resultType=\u0026#34;com.eoezora.mybatisDemo.pojo.EoeAccount\u0026#34;\u0026gt; SELECT * FROM account \u0026lt;where\u0026gt; \u0026lt;choose\u0026gt;\u0026lt;!-- 类似switch --\u0026gt; \u0026lt;when test=\u0026#34;id \u0026gt; 0\u0026#34;\u0026gt;\u0026lt;!-- 类似case --\u0026gt; id = #{id} \u0026lt;/when\u0026gt; \u0026lt;when test=\u0026#34;name != null and name != \u0026#39;\u0026#39;\u0026#34;\u0026gt; name like #{name} \u0026lt;/when\u0026gt; \u0026lt;when test=\u0026#34;age \u0026gt; 0\u0026#34;\u0026gt; age = #{age} \u0026lt;/when\u0026gt; \u0026lt;otherwise\u0026gt;1 = 1\u0026lt;/otherwise\u0026gt;\u0026lt;!-- 类似default 使用where标签可以去掉这个 --\u0026gt; \u0026lt;/choose\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; 参数传递 Mybatis接口方法可以接受各种各样的参数，底层会对这些参数进行不同的封装处理\n单个参数: POJO类型\nMap集合\nCoolection\nList\nArray\n其他类型\n多个参数: 类似EoeAccount selectAccount(@Param(\u0026ldquo;id\u0026rdquo;)int id, @Param(\u0026ldquo;name\u0026rdquo;)String name\u0026hellip;); 参数需要有@Param注解,里面的值与xml映射文件里的占位符一致\n#:D 参数占位符 #{}: 执行SQL时, 会将#{}占位符替换成 ? 会自动设置参数, 防止sql注入\n${}: 拼SQL语句,会出现sql注入问题.\n一般在传参数时使用 #{} 在对表名，列名进行动态设置时，使用${} 进行拼接.\nparameterType 用于设置传入的参数类型, 此属性可以省略\nresultType 执行SQL语句后返回的数据进行封装，此属性指定封装后的类型\nxml中特殊字符处理 在xml文件写SQL语句时难免会出现 大于小于的判断 而 \u0026lt; 是xml标签起始。所以需要进行处理。下面为例子\n\u0026lt;select id=\u0026#34;selectAccount\u0026#34; parameterType=\u0026#34;int\u0026#34; resultType=\u0026#34;com.eoezora.mybatisDemo.pojo.EoeAccount\u0026#34;\u0026gt; SELECT * FROM account \u0026lt;!-- 此处的小于号 \u0026lt; 会报错, 因为被xml判定成了不完成的标签 --\u0026gt; WHERE id \u0026lt; 5; \u0026lt;/select\u0026gt; \u0026lt;!-- 正确的写法应该是 CDATA 或者 转义字符 --\u0026gt; \u0026lt;select id=\u0026#34;selectAccount\u0026#34; parameterType=\u0026#34;int\u0026#34; resultType=\u0026#34;com.eoezora.mybatisDemo.pojo.EoeAccount\u0026#34;\u0026gt; SELECT * FROM account WHERE id \u0026lt;!-- 把他也输符号写在CDATA 里就不会报错了 --\u0026gt; \u0026lt;![CDATA[ \u0026lt; ]]\u0026gt; #{id}; \u0026lt;/select\u0026gt; ","permalink":"https://watson-cat.github.io/posts/mybatis/mybatis-%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/","summary":"增删改查例子 AccountMapper.xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;!-- namespace是映射接口的路径 --\u0026gt; \u0026lt;mapper namespace=\u0026#34;com.eoezora.mybatisDemo.mapper.AccountMapper\u0026#34;\u0026gt; \u0026lt;!-- 添加数据, 参数POJO -\u0026gt; EoeAccount --\u0026gt; \u0026lt;!-- 添加这两个 useGeneratedKeys=\u0026#34;true\u0026#34; keyProperty=\u0026#34;id\u0026#34; 属性在insert标签里可以返回主键 --\u0026gt; \u0026lt;insert id=\u0026#34;addAccount\u0026#34; useGeneratedKeys=\u0026#34;true\u0026#34; keyProperty=\u0026#34;id\u0026#34;/\u0026gt; \u0026lt;insert id=\u0026#34;addAccount\u0026#34; \u0026gt; INSERT INTO account (name, age, brithDay, location) \u0026lt;!-- 这里的名字要与POJO类力的变量名一致 --\u0026gt; VALUES (#{name},#{age},#{brithDay},#{location}); \u0026lt;/insert\u0026gt; \u0026lt;!-- 删除一条数据 --\u0026gt; \u0026lt;delete id=\u0026#34;delAccouintById\u0026#34;\u0026gt; DELETE FROM account WHERE id = #{id} \u0026lt;/delete\u0026gt; \u0026lt;!-- 删除多条数据 --\u0026gt; \u0026lt;delete id=\u0026#34;delAccouintByIds\u0026#34;\u0026gt; DELETE FROM account WHERE id in \u0026lt;!","title":"JavaWEB笔记-MyBatis-增删改查"},{"content":"简介\n","permalink":"https://watson-cat.github.io/posts/mybatis/mybatis-%E9%85%8D%E7%BD%AE/","summary":"简介","title":"JavaWEB笔记-MyBatis配置文件"},{"content":"介绍 Request: 获取请求数据 Response: 设置响应数据 Request 获取请求数据 一些需要了解的方法\n@Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // http://localhost:8080/EoeWebDemo_war/test?username=aas\u0026amp;password=1234567 // 请求行的数据 req.getMethod(); // GET 提交方法 req.getContextPath(); // EoeWebDemo_war 虚拟路径 req.getRequestURL(); // http://localhost:8080/EoeWebDemo_war/test req.getRequestURI(); // /EoeWebDemo_war/test req.getQueryString(); // username=aas\u0026amp;password=1234567 //请求头的数据, 根据请求头名称获取值 req.getHeader(\u0026#34;User-Agent\u0026#34;); //Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36 } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //获取POST请求体的数据 //获取流对象 // BufferedReader getReader()：获取字符输入流 只能操作字符数据 // ServletInputStream getInputStream()：获取字节输入流 可以操作所有类型数据 req.getInputStream(); req.getReader(); } Reuqest提供的获取参数的方法,不管是get还是post都通用\n//获取所有参数 Map\u0026lt;String, String[]\u0026gt; stringMap = req.getParameterMap(); //获取指定参数名的多个值 String[] pars = req.getParameterValues(\u0026#34;某个参数名\u0026#34;); //获取指定参数的单个值 String par = req.getParameter(\u0026#34;某个参数名\u0026#34;); 中文参数乱码解决方式 浏览器对url中的中文会进行URL编码,而Tomcat在解码时使用的字符集是ISO-8859-1, 会导致中文乱码.\n//POST请求直接使用这个方法设置即可 req.setCharacterEncoding(\u0026#34;UTF-8\u0026#34;); //GET请求需要我们手动对字符串进行编码解码操作 //把收到的字符串转为二进制 byte[] bytes = req.getParameter(\u0026#34;参数名\u0026#34;).getBytes(); //在用utf8字符集把二进制数据转成String String newParame = new String(bytes, StandardCharsets.UTF_8); 请求转发 一种服务器内部资源跳转方式\n特点\n浏览器地址栏不会发生变化 转发只能转到服务器内部资源 转发是一次请求,可以使用request共享数据 //转发资源间共享数据方式 request.setAttribute(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;); request.getAttribute(\u0026#34;key\u0026#34;); request.removeAttribute(\u0026#34;key\u0026#34;); //请求转发 request.getRequestDispatcher(\u0026#34;其他资源的访问路径\u0026#34;).forward(request,response); Response 一些方法\n@Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //设置响应代码 response.setStatus(200); //设置响应头 response.setHeader(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;); //获取字符输出流 response.getWriter(); //获取字节输出流 response.getOutputStream(); } Response重定向 介绍：一种资源跳转方式\n特点\n地址栏路径发生变化 可以重定向到任意位置资源, 服务器内部, 外部都可 两次请求,不能在多个资源共享数据 实现方式\n//设置重定向代码 response.setStatus(302); //设置重定向路径 //需要添加request.getContextPath()虚拟目录 response.setHeader(\u0026#34;Location\u0026#34;, request.getContextPath() + \u0026#34;/ts\u0026#34;); //简化方式, 使用这个 response.sendRedirect(request.getContextPath() + \u0026#34;/ts\u0026#34;); 响应字符数据 //response.setHeader(\u0026#34;Content-Type\u0026#34;,\u0026#34;text/html\u0026#34;); response.setContentType(\u0026#34;text/html;charset=utf-8\u0026#34;); PrintWriter pw = response.getWriter(); pw.write(\u0026#34;aaaaa\u0026#34;); pw.write(\u0026#34;\u0026lt;h1\u0026gt;aaaaa\u0026lt;/h1\u0026gt;\u0026#34;); //响应完成后, response 会被销毁, PrintWriter会被服务器关闭 //响应字节流数据 FileInputStream fileInputStream = new FileInputStream(\u0026#34;/bg.jpg\u0026#34;); ServletOutputStream out = response.getOutputStream(); byte[] buffer = new byte[1024]; while ((lenght = fileInputStream.read(buffer)) != -1) { out.write(buffer,0,lenght); } fileInputStream.close(); ","permalink":"https://watson-cat.github.io/posts/javaweb/javaweb-%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94/","summary":"介绍 Request: 获取请求数据 Response: 设置响应数据 Request 获取请求数据 一些需要了解的方法\n@Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // http://localhost:8080/EoeWebDemo_war/test?username=aas\u0026amp;password=1234567 // 请求行的数据 req.getMethod(); // GET 提交方法 req.getContextPath(); // EoeWebDemo_war 虚拟路径 req.getRequestURL(); // http://localhost:8080/EoeWebDemo_war/test req.getRequestURI(); // /EoeWebDemo_war/test req.getQueryString(); // username=aas\u0026amp;password=1234567 //请求头的数据, 根据请求头名称获取值 req.getHeader(\u0026#34;User-Agent\u0026#34;); //Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36 } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //获取POST请求体的数据 //获取流对象 // BufferedReader getReader()：获取字符输入流 只能操作字符数据 // ServletInputStream getInputStream()：获取字节输入流 可以操作所有类型数据 req.","title":"JavaWEB笔记-请求和响应"},{"content":"简介: 一个用于数据持久层的框架\n基本配置 //mybatis配置文件 String resource = \u0026#34;mybatis-config.xml\u0026#34;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); try (SqlSession session = sqlSessionFactory.openSession()) { //此处是直接调用方法进行操作，建议使用代理开发 List\u0026lt;EoeAccount\u0026gt; datas = session.selectList(\u0026#34;test.selectAll\u0026#34;); datas.forEach(System.out::println); session.close(); } Mybatis配置文件(mybatis-config.xml)\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;https://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;environment id=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;/\u0026gt; \u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/eoezora?useSSL=false\u0026amp;amp;allowPublicKeyRetrieval=true\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper resource=\u0026#34;mappers/TestDemoMapper.xml\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;/configuration\u0026gt; SQL语句\n映射文件(TestDemoMapper.xml)\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;!-- 代理开发中 namespace的值应该是 Mapper接口的全限定名 --\u0026gt; \u0026lt;!-- 例如 com.eoezora.mapper.TestDemoMapper --\u0026gt; \u0026lt;mapper namespace=\u0026#34;test\u0026#34;\u0026gt; \u0026lt;!-- resultType 返回值 --\u0026gt; \u0026lt;select id=\u0026#34;selectAll\u0026#34; resultType=\u0026#34;com.eoezora.pojo.EoeAccount\u0026#34;\u0026gt; SELECT * FROM account; \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; Mapper代理开发 定义与SQL映射文件同名的Mapper接口,并且将Mapper接口与SQL映射文件放置在同名文件下\n设置SQL映射文件的namespace属性与Mapper接口全限定名\n在Mapper接口中定义方法,方法名是SQL映射文件中的sql语句ID，并保持参数类型和返回值类型一致\ntry (SqlSession session = sqlSessionFactory.openSession()) { //获取Mapper接口 TestDemoMapper testDemoMapper = session.getMapper(TestDemoMapper.class); //使用接口调用方法 testDemoMapper.selectAll().forEach(System.out::println); } 设置别名 在Nybatis的sql的映射文件中,会使用paramterType、resultType 来设置 sql 语句的输入输出参数，一般参数都是基本的数据类型或封装类型，但都需要声明该类型的全路径，java.lang.String，或者 cn.com.mybatis.pojo.User, 这时就可以通过 typeAliases设置别名,简化复杂度，提高阅读性, 例子如下\n\u0026lt;select id=\u0026#34;selectUserByName\u0026#34; parameterType=\u0026#34;java.lang.String\u0026#34; resultType=\u0026#34;com.mybatis.pojo.User\u0026#34;\u0026gt; SELECT * FROM USER WHERE username LIKE \u0026#39;%${value}%\u0026#39; \u0026lt;/select\u0026gt; 使用别名简化后\n\u0026lt;typeAliases\u0026gt; \u0026lt;typeAlias alias=\u0026#34;user\u0026#34; type=\u0026#34;com.mybatis.pojo.User\u0026#34;/\u0026gt; \u0026lt;typeAlias alias=\u0026#34;string\u0026#34; type=\u0026#34;java.lang.String\u0026#34;/\u0026gt; \u0026lt;/typeAliases\u0026gt; \u0026lt;!-- paramterType、resultType直接使用别名 --\u0026gt; \u0026lt;select id=\u0026#34;selectUserByName\u0026#34; parameterType=\u0026#34;string\u0026#34; resultType=\u0026#34;user\u0026#34;\u0026gt; SELECT * FROM USER WHERE username LIKE \u0026#39;%${value}%\u0026#39; \u0026lt;/select\u0026gt; 其他\n批量添加别名,以下设置,会为该包下的所有类自动添加别名,为对应类名的首字母小写 User -\u0026gt; user\n\u0026lt;typeAliases\u0026gt; \u0026lt;package name=\u0026#34;com.mybatis.pojo\u0026#34;/\u0026gt; \u0026lt;/typeAliases ","permalink":"https://watson-cat.github.io/posts/mybatis/mybatis/","summary":"简介: 一个用于数据持久层的框架\n基本配置 //mybatis配置文件 String resource = \u0026#34;mybatis-config.xml\u0026#34;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); try (SqlSession session = sqlSessionFactory.openSession()) { //此处是直接调用方法进行操作，建议使用代理开发 List\u0026lt;EoeAccount\u0026gt; datas = session.selectList(\u0026#34;test.selectAll\u0026#34;); datas.forEach(System.out::println); session.close(); } Mybatis配置文件(mybatis-config.xml)\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;https://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;environment id=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;/\u0026gt; \u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/eoezora?useSSL=false\u0026amp;amp;allowPublicKeyRetrieval=true\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper resource=\u0026#34;mappers/TestDemoMapper.xml\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;/configuration\u0026gt; SQL语句","title":"JavaWEB笔记-MyBatis快速入门笔记"},{"content":"DriverManager //创建一个链接 String url = \u0026#34;jdbc:mysql://localhost/database?useSSL=false\u0026amp;allowPublicKeyRetrieval=true\u0026#34;; String user = \u0026#34;\u0026#34;; String pwd = \u0026#34;\u0026#34;; Connection connection = DriverManager.getConnection(url,user,pwd); Connection 用于获取执行SQL的对象和管理事务\n//创建链接 Connection connection = DriverManager.getConnection(url,user,pwd); //要执行的SQL语句 String sql = \u0026#34;UPDATE users SET money = 1000 WHERE id = 114514;\u0026#34;; //创建执行对象 Statement statement = connection.createStatement(); try { //开启事务 connection.setAutoCommit(false); //执行语句 statement.executeUpdate(sql); //事务提交 connection.commit(); } catch (Exception e) { //若执行失败则回滚事务 connection.rollback(); throw new RuntimeException(e); } Statement 作用：执行SQL语句\n//执行DML DDL 语句， 增删改，返回受影响的行数 int executeUpdate(String sql) //执行DQL语句 返回ResultSet结果集对象,查询语句 ResultSet executeQuery(String sql) ResultSet 作用：一个结果集对象，封装了DQL查询语句的结果\n//执行DQL语句返回ResultSet对象 ResultSet rs = statement.executeQuery(sql); //将光标从当前位置往前移动一行，判断当前是否为有效行 boolean next(); //true 有效行，当前行有数据 | 无效行 当前行无数据 //获取数据 //数据类型 get数据类型(参数); String getString(int index); //获取字段名 name 的值 ResultSet rs = statement.executeQuery(sql); while (rs.next()) { System.out.println(rs.getString(\u0026#34;name\u0026#34;)); } PreparedStatement 作用：预编译SQL语句并执行，预防SQL注入问题\nSQL注入是通过操作输入来修改事先定义号的SQL语句，用以达到攻击服务器的作用\nConnection connection = DriverManager.getConnection(url,user,pwd); String sql = \u0026#34;SELECT * FROM goods WHERE id = ?\u0026#34;; //获取预编译Sql对象 PreparedStatement ps = connection.prepareStatement(sql); //设置 ？的参数值 //参数位置 | 参数值 ps.setInt(1,1); //执行语句 ResultSet rs = ps.executeQuery(); rs.next(); System.out.println(rs.getString(\u0026#34;name\u0026#34;)); ","permalink":"https://watson-cat.github.io/posts/jdbc-note/api%E8%AF%A6%E8%A7%A3/","summary":"DriverManager //创建一个链接 String url = \u0026#34;jdbc:mysql://localhost/database?useSSL=false\u0026amp;allowPublicKeyRetrieval=true\u0026#34;; String user = \u0026#34;\u0026#34;; String pwd = \u0026#34;\u0026#34;; Connection connection = DriverManager.getConnection(url,user,pwd); Connection 用于获取执行SQL的对象和管理事务\n//创建链接 Connection connection = DriverManager.getConnection(url,user,pwd); //要执行的SQL语句 String sql = \u0026#34;UPDATE users SET money = 1000 WHERE id = 114514;\u0026#34;; //创建执行对象 Statement statement = connection.createStatement(); try { //开启事务 connection.setAutoCommit(false); //执行语句 statement.executeUpdate(sql); //事务提交 connection.commit(); } catch (Exception e) { //若执行失败则回滚事务 connection.rollback(); throw new RuntimeException(e); } Statement 作用：执行SQL语句\n//执行DML DDL 语句， 增删改，返回受影响的行数 int executeUpdate(String sql) //执行DQL语句 返回ResultSet结果集对象,查询语句 ResultSet executeQuery(String sql) ResultSet 作用：一个结果集对象，封装了DQL查询语句的结果","title":"JavaWEB笔记-JDBC-API详解"},{"content":"简介: 数据库连接池是个容器, 负责分配, 管理数据库链接, 允许应用程序重复使用现有的数据库链接, 而不是重新建立一个新连接\n标准接口: DataSource\nDruid配置文件 url=jdbc:mysql:///eoezora?useSSL=false\u0026amp;allowPublicKeyRetrieval=true username=root password=root #初始化连接数量 initialSize=5 #最大连接数 maxActive=10 #最大等待时间 ms maxWait=3000 加载配置 //1.加载配置文件 Properties pro = new Properties(); InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream(\u0026#34;druid.properties\u0026#34;); pro.load(is); //2.获取连接池对象 DataSource ds = DruidDataSourceFactory.createDataSource(pro); //3.获取连接 Connection conn = ds.getConnection(); 归还连接|释放资源 public static void close(ResultSet rs, Statement stmt, Connection conn){ if (rs!=null) { try { rs.close(); } catch (Exception e) { System.out.println(e.getMessage()); } } if (stmt!=null) { try { stmt.close(); } catch (Exception e) { System.out.println(e.getMessage()); } } if (conn!=null){ try { conn.close();//归还连接 } catch (Exception e) { System.out.println(e.getMessage()); } } } ","permalink":"https://watson-cat.github.io/posts/jdbc-note/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/","summary":"简介: 数据库连接池是个容器, 负责分配, 管理数据库链接, 允许应用程序重复使用现有的数据库链接, 而不是重新建立一个新连接\n标准接口: DataSource\nDruid配置文件 url=jdbc:mysql:///eoezora?useSSL=false\u0026amp;allowPublicKeyRetrieval=true username=root password=root #初始化连接数量 initialSize=5 #最大连接数 maxActive=10 #最大等待时间 ms maxWait=3000 加载配置 //1.加载配置文件 Properties pro = new Properties(); InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream(\u0026#34;druid.properties\u0026#34;); pro.load(is); //2.获取连接池对象 DataSource ds = DruidDataSourceFactory.createDataSource(pro); //3.获取连接 Connection conn = ds.getConnection(); 归还连接|释放资源 public static void close(ResultSet rs, Statement stmt, Connection conn){ if (rs!=null) { try { rs.close(); } catch (Exception e) { System.out.println(e.getMessage()); } } if (stmt!=null) { try { stmt.","title":"JavaWEB笔记-JDBC-连接池"},{"content":"多表查询 连接查询 内连接 获取两表的交集数据\n-- 隐式写法 SELECT 字段列表 FROM 表1, 表2... WHERE 条件; -- 显示写法 SELECT 字段列表 FROM 表1 INNER JOIN 表2 ON 条件 外连接 左外连接: 相当于查询A表所有数据和交集部分的数据\n右外连接: 相当于查询B表所有数据和交集部分的数据\n-- 左外连接 SELECT 字段列表 FROM 表1 LEFT OUTER JOIN 表2 ON 条件 -- 右外连接 SELECT 字段列表 FROM 表1 RIGHT OUTER JOIN 表2 ON 条件 子查询 概念：查询中嵌套查询,根据查询结果不同，作用不同分为 单行单列，多行单列，多行多列\n-- 单行单列: 作为条件值 使用 = != \u0026gt; \u0026lt; 进行条件判断 SELECT 字段列表 FROM 表 WHERE 字段名 = (子查询语句); -- 多行单列: 作为条件值 SELECT 字段列表 FROM 表 WHERE 字段名 IN (子查询语句); -- 多行多列: 作为虚拟表 SELECT 字段列表 FROM (子查询语句) WHERE 条件; -- 例子 查询工资大于 蔡徐坤 的数据 SELECT name FROM users WHERE money \u0026gt; (SELECT money FROM infos WHERE name = \u0026#34;蔡徐坤\u0026#34;); ","permalink":"https://watson-cat.github.io/posts/mysql-note/%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/","summary":"多表查询 连接查询 内连接 获取两表的交集数据\n-- 隐式写法 SELECT 字段列表 FROM 表1, 表2... WHERE 条件; -- 显示写法 SELECT 字段列表 FROM 表1 INNER JOIN 表2 ON 条件 外连接 左外连接: 相当于查询A表所有数据和交集部分的数据\n右外连接: 相当于查询B表所有数据和交集部分的数据\n-- 左外连接 SELECT 字段列表 FROM 表1 LEFT OUTER JOIN 表2 ON 条件 -- 右外连接 SELECT 字段列表 FROM 表1 RIGHT OUTER JOIN 表2 ON 条件 子查询 概念：查询中嵌套查询,根据查询结果不同，作用不同分为 单行单列，多行单列，多行多列\n-- 单行单列: 作为条件值 使用 = != \u0026gt; \u0026lt; 进行条件判断 SELECT 字段列表 FROM 表 WHERE 字段名 = (子查询语句); -- 多行单列: 作为条件值 SELECT 字段列表 FROM 表 WHERE 字段名 IN (子查询语句); -- 多行多列: 作为虚拟表 SELECT 字段列表 FROM (子查询语句) WHERE 条件; -- 例子 查询工资大于 蔡徐坤 的数据 SELECT name FROM users WHERE money \u0026gt; (SELECT money FROM infos WHERE name = \u0026#34;蔡徐坤\u0026#34;); ","title":"Mysql笔记-数据库设计-多表查询"},{"content":"表之间的关系 一对一 例如，用户表和用户信息表(不常用的信息)\n实现方式: 在任意一方加入外键，关联另一方主键，并且设置外键为唯一(UNIQUE)\n一对多(多对一) 例如：一个部门有多个员工，多个员工属于一个部门\n实现方式：在多的一方添加一个外键，指向一的主键,例如 在员工表里添加一个部门ID外键，指向部门表的主键\n多对多 例如：商品和订单，一个订单多个商品，一个商品多个订单\n实现方式：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键\n订单表\nid 支付金额 支付方式 状态 1 114514.0 WeChatPay 未支付 2 19198.0 AliPay 已支付 商品表\nid 商品名 价格 1 林檎 114514 2 迎宾酒 1919810 中间表\nid 订单id(外键) 商品id(外键) 1 1 1 2 1 2 3 2 1 注解：以上方三表为例，中间表记录订单与商品的外键。两个订单id为1的数据代表着这个订单有两件商品\n-- 订单与商品关联例子 create table if not exists orders ( id int auto_increment primary key, payment int not null, paytype varchar(20) not null, status varchar(20) not null ); create table if not exists goods ( id int auto_increment primary key, name varchar(60) not null, price int not null ); create table if not exists tk_orders_goods ( id int auto_increment primary key, order_id int not null, good_id int not null ); -- 添加外键 alter table tk_orders_goods add constraint fk_order_id FOREIGN KEY(order_id) REFERENCES orders(id); -- 添加外键 alter table tk_orders_goods add constraint fk_good_id FOREIGN KEY(good_id) REFERENCES goods(id); ","permalink":"https://watson-cat.github.io/posts/mysql-note/%E8%A1%A8%E4%B9%8B%E9%97%B4%E5%85%B3%E7%B3%BB/","summary":"表之间的关系 一对一 例如，用户表和用户信息表(不常用的信息)\n实现方式: 在任意一方加入外键，关联另一方主键，并且设置外键为唯一(UNIQUE)\n一对多(多对一) 例如：一个部门有多个员工，多个员工属于一个部门\n实现方式：在多的一方添加一个外键，指向一的主键,例如 在员工表里添加一个部门ID外键，指向部门表的主键\n多对多 例如：商品和订单，一个订单多个商品，一个商品多个订单\n实现方式：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键\n订单表\nid 支付金额 支付方式 状态 1 114514.0 WeChatPay 未支付 2 19198.0 AliPay 已支付 商品表\nid 商品名 价格 1 林檎 114514 2 迎宾酒 1919810 中间表\nid 订单id(外键) 商品id(外键) 1 1 1 2 1 2 3 2 1 注解：以上方三表为例，中间表记录订单与商品的外键。两个订单id为1的数据代表着这个订单有两件商品\n-- 订单与商品关联例子 create table if not exists orders ( id int auto_increment primary key, payment int not null, paytype varchar(20) not null, status varchar(20) not null ); create table if not exists goods ( id int auto_increment primary key, name varchar(60) not null, price int not null ); create table if not exists tk_orders_goods ( id int auto_increment primary key, order_id int not null, good_id int not null ); -- 添加外键 alter table tk_orders_goods add constraint fk_order_id FOREIGN KEY(order_id) REFERENCES orders(id); -- 添加外键 alter table tk_orders_goods add constraint fk_good_id FOREIGN KEY(good_id) REFERENCES goods(id); ","title":"Mysql笔记-数据库设计-表之间的关系"},{"content":"事务概念 数据库的事务是一种机制，一个操作序列，包含一组数据库操作命令 事务把所有命令作为一个整体向系统提交或撤销。这组命令要么同时成功，要么同时失败 -- 定义事务开启 -- 事务开启后所作的操作为临时性的 BEGIN; -- 也可以使用 START TRANSACTION; UPDATE account SET money = money + 1000 WHERE name = \u0026#39;蔡徐坤\u0026#39;; 假设这行语句错误 UPDATE account SET money = money - 8000 WHERE name = \u0026#39;孙笑川\u0026#39;; -- 提交事务 COMMIT; -- 回滚操作 ROLLBACK; 事务四大特性 原子性：事务是不可分割的最小操作单位，要么同时成功，要么同时失败；\n一致性：事务完成后，必须是所有数据都保持一致状态\n隔离性：多个事务之间，操作的可见性。每个事务之间操作隔离\n持久性：事务一旦提交或者回滚，他对数据库的改变就是永久的\n-- 查看事务默认提交方式 SELECT @@autocommit; -- 修改默认提交方式 - 1 自动提交 - 0 手动提交 set @@autocommit = 0; ","permalink":"https://watson-cat.github.io/posts/mysql-note/%E4%BA%8B%E5%8A%A1/","summary":"事务概念 数据库的事务是一种机制，一个操作序列，包含一组数据库操作命令 事务把所有命令作为一个整体向系统提交或撤销。这组命令要么同时成功，要么同时失败 -- 定义事务开启 -- 事务开启后所作的操作为临时性的 BEGIN; -- 也可以使用 START TRANSACTION; UPDATE account SET money = money + 1000 WHERE name = \u0026#39;蔡徐坤\u0026#39;; 假设这行语句错误 UPDATE account SET money = money - 8000 WHERE name = \u0026#39;孙笑川\u0026#39;; -- 提交事务 COMMIT; -- 回滚操作 ROLLBACK; 事务四大特性 原子性：事务是不可分割的最小操作单位，要么同时成功，要么同时失败；\n一致性：事务完成后，必须是所有数据都保持一致状态\n隔离性：多个事务之间，操作的可见性。每个事务之间操作隔离\n持久性：事务一旦提交或者回滚，他对数据库的改变就是永久的\n-- 查看事务默认提交方式 SELECT @@autocommit; -- 修改默认提交方式 - 1 自动提交 - 0 手动提交 set @@autocommit = 0; ","title":"Mysql笔记-事务"},{"content":"约束概念 约束是作用于表中列的规则，用于限制加入表的数据 约束的存在保证数据库数据的正确性，有限性和完整性 约束的分类 约束名称 功能描述 关键字 非空约束 保证列中数据不出现null NOT NULL 唯一约束 保证列中数据各不相同，唯一性 UNIQUE 主键约束 主键是一行数据的唯一标识，要求非空且唯一 PRIMARY KEY 默认约束 保存数据时,未指定就采用默认值 DEFAULT 外键约束 外键让两个表的数据之间建立连接，保证数据一致且完整 FOREIGN KEY 例子 -- 建表时对字段进行约束 CREATE TABLE emp( id INT PRIMARY KEY, -- 唯一主键 ename VARCHAR(60) NOT NULL UNIQUE, -- 非空且唯一 joindate DATE NOT NULL, -- 非空 salary DOUBLE(7,2) NOT NULL, -- 非空 bonus DOUBLE(7,2) DEFAULT 0, -- 默认为0 -- 部门id dept_id INT NOT NULL, -- 添加外键dept_id并关联dept表的id主键 CONSTRAINF fk_emp_dept FOREIGN KEY(dept_id) REFERENCES dept(id) ); 外键约束 员工表(emp)\nid name age dep_id 1 张三 22 1 2 李四 23 1 3 王五 24 2 4 赵六 25 2 部门表(dept)\nid dep_name addr 1 研发部 研发部地址 2 产品部 产品部地址 ","permalink":"https://watson-cat.github.io/posts/mysql-note/%E7%BA%A6%E6%9D%9F/","summary":"约束概念 约束是作用于表中列的规则，用于限制加入表的数据 约束的存在保证数据库数据的正确性，有限性和完整性 约束的分类 约束名称 功能描述 关键字 非空约束 保证列中数据不出现null NOT NULL 唯一约束 保证列中数据各不相同，唯一性 UNIQUE 主键约束 主键是一行数据的唯一标识，要求非空且唯一 PRIMARY KEY 默认约束 保存数据时,未指定就采用默认值 DEFAULT 外键约束 外键让两个表的数据之间建立连接，保证数据一致且完整 FOREIGN KEY 例子 -- 建表时对字段进行约束 CREATE TABLE emp( id INT PRIMARY KEY, -- 唯一主键 ename VARCHAR(60) NOT NULL UNIQUE, -- 非空且唯一 joindate DATE NOT NULL, -- 非空 salary DOUBLE(7,2) NOT NULL, -- 非空 bonus DOUBLE(7,2) DEFAULT 0, -- 默认为0 -- 部门id dept_id INT NOT NULL, -- 添加外键dept_id并关联dept表的id主键 CONSTRAINF fk_emp_dept FOREIGN KEY(dept_id) REFERENCES dept(id) ); 外键约束 员工表(emp)","title":"Mysql笔记-约束"},{"content":"SELECT -- 字段列表 FROM -- 表名列表 WHERE -- 条件列表 GROUP BY -- 分组列表 HAVING -- 分组后条件 ORDER BY -- 排序字段 LIMIT -- 限制查询返回数据的数量，用于分页限制 条件查询 -- 查询表里许所有数据,不建议使用 SELECT * FROM users; -- 查询名字 -- DISTINCT 去除重复 SELECT DISTINCT name FROM users; -- 查询名字，性别，年龄 -- 可以使用 sex as 性别 的方式对列起别名,也可以写成 sex 性别 省略as 但字段名跟别名之间要有空格隔开 SELECT name, sex as 性别, age as 年龄 FROM users; -- 条件查询符号, NULL值比较使用 IS NOT NULL 跟 IS NULL SELECT name FROM users WHERE age \u0026gt; 17; -- 查询age数值大于17的数据 SELECT name FROM users WHERE age \u0026gt;= 7 AND age \u0026lt;= 50; -- 查询age数值在7跟50之间的数值(写法一) SELECT name FROM users WHERE age BETWEEN 7 AND 50; -- 查询age数值在7跟50之间的数值(写法二) -- 查询brith_day数值在\u0026#39;2000-01-01\u0026#39;跟\u0026#39;2000-04-01\u0026#39;之间的数值(写法二) SELECT name FROM users WHERE brith_day BETWEEN \u0026#39;2000-01-01\u0026#39; AND \u0026#39;2000-04-01\u0026#39;; SELECT name FROM users WHERE age = 17; -- 查询age数值等于17的数据 SELECT name FROM users WHERE age != 17; -- 查询age数值不等于17的数据(写法一) SELECT name FROM users WHERE age \u0026lt;\u0026gt; 17; -- 查询age数值不等于17的数据(写法二) SELECT name FROM users WHERE age = 17 OR age = 18 OR age = 22;-- 查询age数值等于17或18或22的数据(写法一) SELECT name FROM users WHERE age IN (17，18，22); -- 查询age数值等于17或18或22的数据(写法二) SELECT name FROM users WHERE age IS NULL; -- 查询age数值为null的数据 SELECT name FROM users WHERE age IS NOT NULL; -- 查询age数值不为null的数据 SELECT name FROM users WHERE age IS NULL -- 查询age数值为null的数据 /* 通配符 _ 下划线代表单个字符 % 百分号代表任意个数字符 */ -- 查询姓为 蔡 的名字信息 SELECT name FROM users WHERE name like \u0026#39;蔡%\u0026#39;; -- 查询名字 第二个字是 徐 的名字信息 SELECT name FROM users WHERE name like \u0026#39;_徐%\u0026#39;; -- 查询名字中包含坤的名字信息 SELECT name FROM users WHERE name like \u0026#39;%坤%\u0026#39;; 排序查询 -- 排序查询语法 SELECT 字段列表 FROM 表名 ORDER BY 排序字段名1 [排序方式1]，排序字段名2 [排序方式2]...; -- 排序方式 -- ASC 升序排列[默认] -- DESC 降序排列 -- 升序排序例子 SELECT name FROM users ORDER BY age ASC; -- 降序排序例子 SELECT name FROM users ORDER BY age DESC; -- 多字段降序排序例子 -- 如果年龄一样，则按工资升序排序 SELECT name FROM users ORDER BY age DESC, money ASC; 分组查询 -- 聚合函数查询 count(列名) -- 统计数量 max(列名) -- 最大值 min(列名) -- 最小值 sum(列名) -- 求和 avg(列名) -- 求平均值 -- 聚合函数查询语法 SELECT 聚合函数(列名)... FROM users; SELECT COUNT(name) FROM users; -- 统计name有几个，不能为空，不会统计null值 SELECT MAX(age) FROM users； -- 求年龄最大的 SELECT MIN(age) FROM users； -- 求年龄最小的 SELECT SUM(money) FROM users； -- 求一整列的 money 和 SELECT AVG(money) FROM users； -- 求一整列的 money 的平均值 -- 分组查询 -- 根据性别分组查询平均工资 SELECT sex, avg(money) FROM users GROUP BY sex; -- 根据性别分组查询平均工资，只计算工资高于5000的数据 SELECT sex, avg(money) FROM users WHERE money \u0026gt; 5000 GROUP BY sex; -- 根据性别分组查询平均工资，只计算工资高于5000的数据, 且数据大于2条 SELECT sex, avg(money) FROM users WHERE money \u0026gt; 5000 GROUP BY sex HAVING COUNT(*) \u0026gt; 2; 分页查询 -- 语法 SELECT name SELECT name FROM users LIMIT 起始索引，查询数目量; -- 从0开始查，查询3条数据 SELECT name FROM users LIMIT 0，3; -- 分页查询 SELECT name FROM users LIMIT (当前页面 -1) * 每页显示条目数，每页显示条目数; ","permalink":"https://watson-cat.github.io/posts/mysql-note/%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2/","summary":"SELECT -- 字段列表 FROM -- 表名列表 WHERE -- 条件列表 GROUP BY -- 分组列表 HAVING -- 分组后条件 ORDER BY -- 排序字段 LIMIT -- 限制查询返回数据的数量，用于分页限制 条件查询 -- 查询表里许所有数据,不建议使用 SELECT * FROM users; -- 查询名字 -- DISTINCT 去除重复 SELECT DISTINCT name FROM users; -- 查询名字，性别，年龄 -- 可以使用 sex as 性别 的方式对列起别名,也可以写成 sex 性别 省略as 但字段名跟别名之间要有空格隔开 SELECT name, sex as 性别, age as 年龄 FROM users; -- 条件查询符号, NULL值比较使用 IS NOT NULL 跟 IS NULL SELECT name FROM users WHERE age \u0026gt; 17; -- 查询age数值大于17的数据 SELECT name FROM users WHERE age \u0026gt;= 7 AND age \u0026lt;= 50; -- 查询age数值在7跟50之间的数值(写法一) SELECT name FROM users WHERE age BETWEEN 7 AND 50; -- 查询age数值在7跟50之间的数值(写法二) -- 查询brith_day数值在\u0026#39;2000-01-01\u0026#39;跟\u0026#39;2000-04-01\u0026#39;之间的数值(写法二) SELECT name FROM users WHERE brith_day BETWEEN \u0026#39;2000-01-01\u0026#39; AND \u0026#39;2000-04-01\u0026#39;; SELECT name FROM users WHERE age = 17; -- 查询age数值等于17的数据 SELECT name FROM users WHERE age !","title":"Mysql笔记-单表查询"},{"content":"24岁是学生，正在自学编程中，本站记录学习过程中的一些笔记\n","permalink":"https://watson-cat.github.io/about/","summary":"24岁是学生，正在自学编程中，本站记录学习过程中的一些笔记","title":"🙋🏻‍♂️关于"}]