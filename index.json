[{"content":"控制反转Ioc 使用对象时,由主动new产生对象转换为由外部提供对象, 此过程中创建对象控制权由程序转移到外部,此思想称为控制反转\nSpring对Ioc思想的实现\nSpring提供了一个容器,称为Ioc容器，用来充当Ioc思想中的\u0026quot;外部\u0026quot; Ioc容器负责对象创建,初始化等一系工作, 被创建或被管理的对象在Ioc容器中被称为Bean DI(Dependency Injection): 依赖注入\n在容器中建立的Bean与Bean之间的依赖关系的整个过程,称为依赖注入 目标: 充分解耦\n使用Ioc容器管理Bean 在Ioc容器内将有依赖关系的Bean进行关系绑定(DI) 适合给容器管理的Bean\n表现层对象 业务层对象 数据层对象 工具对象 不适合给容器管理的Bean\n封装实体的域对象 xml配置Bean 一个Bean配置文件\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;!--id为Bean名字--\u0026gt; \u0026lt;!--name 为bean起别名--\u0026gt; \u0026lt;!--Class是bean接口对应实现类--\u0026gt; \u0026lt;!--scope时bean的作用范围,默认singleton单例 | prototype非单例 --\u0026gt; \u0026lt;bean id=\u0026#34;bookInfo\u0026#34; class=\u0026#34;com.eoezora.springdemo.dao.impl.PysBookImpl\u0026#34;/\u0026gt; \u0026lt;!--id为Bean名字 Class是bean接口对应实现类--\u0026gt; \u0026lt;bean id=\u0026#34;bookService\u0026#34; class=\u0026#34;com.eoezora.springdemo.services.impl.BookServerImpl\u0026#34;\u0026gt; \u0026lt;!--配置当前Bean的属性--\u0026gt; \u0026lt;!--name属性表示配置哪一个属性--\u0026gt; \u0026lt;!--ref表示参照哪个Bean--\u0026gt; \u0026lt;property name=\u0026#34;bookInfo\u0026#34; ref=\u0026#34;bookInfo\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; Java使用代码\npublic static void main(String[] args) { //根据配置文件获取IoC容器 ApplicationContext ctx = new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); //ctx.getBean(bean的id); BookService bookService = (BookService) ctx.getBean(\u0026#34;bookService\u0026#34;); bookService.addBook(1, \u0026#34;weee\u0026#34;); bookService.getBook(); } 业务层例子\npackage com.eoezora.springdemo.services.impl; import com.eoezora.springdemo.dao.BookInfo; import com.eoezora.springdemo.services.BookService; public class BookServerImpl implements BookService { //使用DI依赖注入时, 业务层Service中使用new的方式创建的对象要删除 //在xml配置DI注入，运行后容器会帮我们自动 BookInfo bookInfo; @Override public BookInfo getBook() { System.out.println(\u0026#34;return a book...\u0026#34;); return null; } @Override public void addBook(int id, String bName) { bookInfo.save(); System.out.println(\u0026#34;add a book -\u0026gt; \u0026#34; + id + \u0026#34; - \u0026#34; + bName); } //Set方法, IoC供容器调用赋值 public void setBookInfo(BookInfo bookInfo) { this.bookInfo = bookInfo; } } 加载properties文件 在applicationContext.xml里开辟一块新的命名空间\n\u0026lt;!-- 新增下面这三行 --\u0026gt; \u0026lt;!--xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34;--\u0026gt; \u0026lt;!--http://www.springframework.org/schema/context--\u0026gt; \u0026lt;!--http://www.springframework.org/schema/context/spring-context.xsd--\u0026gt; \u0026lt;!-- 下面是新增好的 --\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd \u0026#34;\u0026gt; \u0026lt;!--新增一个property占位符, location是要加载的proper文件路径--\u0026gt; \u0026lt;context:property-placeholder location=\u0026#34;bookInfo.properties\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;bookService\u0026#34; scope=\u0026#34;prototype\u0026#34; class=\u0026#34;com.eoezora.springdemo.services.impl.BookServerImpl\u0026#34;\u0026gt; \u0026lt;!--配置当前Bean的属性--\u0026gt; \u0026lt;!--name属性表示配置哪一个属性--\u0026gt; \u0026lt;!--ref表示参照哪个Bean--\u0026gt; \u0026lt;property name=\u0026#34;bookInfo\u0026#34; ref=\u0026#34;bookInfo\u0026#34;/\u0026gt; \u0026lt;!-- 配置完成后就可以使用${key} 的形式读取目标proper文件的内容 --\u0026gt; \u0026lt;bean id=\u0026#34;bookService\u0026#34; scope=\u0026#34;prototype\u0026#34; class=\u0026#34;com.eoezora.springdemo.services.impl.BookServerImpl\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;bookInfo\u0026#34; ref=\u0026#34;bookInfo\u0026#34; value=\u0026#34;${book.name}\u0026#34;/\u0026gt; \u0026lt;!-- 假设 bookInfo.properties如下 --\u0026gt; \u0026lt;!-- book.name=kafka的城堡 --\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 注解开发 Spring3.0后使用纯注解开发,使用**@Configuration**代替了xml配置文件.\n//在实现类上添加注解@Component来定义一个Bean @Component @Component(\u0026#34;bean名字\u0026#34;) public class demo implements someInterface { } //定义一个配置类 @Configuration //设置bean扫描包路径 @ComponentScan(\u0026#34;com.eoezora.spring_ano\u0026#34;) //加载外部配置文件 @PropertySource(\u0026#34;jdbc.properties\u0026#34;) public class SpringConfig { } public static void main(String[] args) { //使用AnnotationConfigApplicationContext加载配置类获取容器 ApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class); IServices services = context.getBean(IServices.class); services.printData(); } 作用范围|生命周期 作用范围: 在接口实现类添加注解 @Scope() 参考xml配置的scope属性\n@Scope(\u0026#34;prototype\u0026#34;) public class CommonServiceImpl implements CommonServices{} Bean的生命周期注解\n//标注在方法上,表示该方法是Bean的初始化方法 @PostConstruct //标注在方法上,表示该方法是Bean的销毁方法 @PreDestroy public void printData() { System.out.println(commonDao.getData()); } 自动装配 //使用注解@Autowired实现自动装配, 按类型来 @Autowired //当有多个同一接口的实现类时,使用@Qualifier实现指定装配 @Qualifier(\u0026#34;bean的名字\u0026#34;) private CommonDao commonDao; /** * @Value装备基本数据类型 * 可以把配置文件里的数值装配到该变量 * 假设在配置文件类里使用了 @PropertySource(\u0026#34;jdbc.properties\u0026#34;) 加载了jdbc配置 * 可以使用 ${key-name} 的形式获取数据 * jdbc.url=http://localhost:3306/eoezora **/ @Value(\u0026#34;${jdbc.url}\u0026#34;) private String url; 注解管理第三方Bean\n//添加@Bean注解表示该方法返回值是一个Bean @Bean public DataSource dataSource() { DruidDataSource ds = new DruidDataSource(); ds.setXXXX(); return ds; } /** * 第三方Bean的依赖注入 * 添加@Bean注解表示该方法返回值是一个Bean * 如果要给第三方的Bean依赖注入,用形参的形式给到对应方法里 * spring会从容器里找到该形参的Bean然后传到指定方法 * 以下方方法为例, 我要传入数据库配置信息获得Druid连接池 * 我定义一个SqlConfig存放数据库信息 * 然后给到dataSource()方法 * Spring会自动帮我们装配参数 */ @Bean public DataSource dataSource(SqlConfig sc) { //bd do something... DruidDataSource ds = new DruidDataSource(); ds.setUrl(sc.getUrl()); return ds; } ","permalink":"https://eoezora.github.io/posts/spring/spring-ioc%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/","summary":"控制反转Ioc 使用对象时,由主动new产生对象转换为由外部提供对象, 此过程中创建对象控制权由程序转移到外部,此思想称为控制反转\nSpring对Ioc思想的实现\nSpring提供了一个容器,称为Ioc容器，用来充当Ioc思想中的\u0026quot;外部\u0026quot; Ioc容器负责对象创建,初始化等一系工作, 被创建或被管理的对象在Ioc容器中被称为Bean DI(Dependency Injection): 依赖注入\n在容器中建立的Bean与Bean之间的依赖关系的整个过程,称为依赖注入 目标: 充分解耦\n使用Ioc容器管理Bean 在Ioc容器内将有依赖关系的Bean进行关系绑定(DI) 适合给容器管理的Bean\n表现层对象 业务层对象 数据层对象 工具对象 不适合给容器管理的Bean\n封装实体的域对象 xml配置Bean 一个Bean配置文件\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;!--id为Bean名字--\u0026gt; \u0026lt;!--name 为bean起别名--\u0026gt; \u0026lt;!--Class是bean接口对应实现类--\u0026gt; \u0026lt;!--scope时bean的作用范围,默认singleton单例 | prototype非单例 --\u0026gt; \u0026lt;bean id=\u0026#34;bookInfo\u0026#34; class=\u0026#34;com.eoezora.springdemo.dao.impl.PysBookImpl\u0026#34;/\u0026gt; \u0026lt;!--id为Bean名字 Class是bean接口对应实现类--\u0026gt; \u0026lt;bean id=\u0026#34;bookService\u0026#34; class=\u0026#34;com.eoezora.springdemo.services.impl.BookServerImpl\u0026#34;\u0026gt; \u0026lt;!--配置当前Bean的属性--\u0026gt; \u0026lt;!--name属性表示配置哪一个属性--\u0026gt; \u0026lt;!--ref表示参照哪个Bean--\u0026gt; \u0026lt;property name=\u0026#34;bookInfo\u0026#34; ref=\u0026#34;bookInfo\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; Java使用代码\npublic static void main(String[] args) { //根据配置文件获取IoC容器 ApplicationContext ctx = new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); //ctx.getBean(bean的id); BookService bookService = (BookService) ctx.","title":"JavaWEB笔记-Spring核心容器"},{"content":"会话 会话:客户端跟服务端的连接,会话建立后直到一方断开连接才会结束.在一次会话中可以包含多次请求和响应 会话跟踪:服务端会识别多个请求是否来自同一个客户端,以便在同次会话的多次请求间共享数据 HTTP协议是无状态的,每次客户端向服务端请求时。服务端都会将该请求视为新的请求,因此我们需要会话跟踪技术来实现会话内数据共享 实现方式: 客户端会话跟踪技术: Cookie 服务端跟会话踪技术: Session Cokkie 客户端会话技术,将数据保存在客户端,以后每次请求都携带Cookie数据进行访问\n基本使用 @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //创建Cookie对象 Cookie cookie = new Cookie(\u0026#34;key\u0026#34;,\u0026#34;value\u0026#34;); //发送cookie到客户端 response.addCookie(cookie); //获取客户端所有cookie Cookie[] cookies = request.getCookies(); //通过遍历获取每个cookie for (Cookie cookie1 : cookies) { System.out.println(cookie1.getName() + \u0026#34; - \u0026#34; + cookie1.getValue()); } } 存活时间 默认情况下, 当浏览器关闭后,内存释放,Cookie会被销毁\n使用方法 cookie.setMaxAge(秒) 设置cookie存活时间\n而参数有以下含义\n正数: 将会cookie写入浏览器所在电脑硬盘,持久化存储到期自动删除 负数: 默认值, Cookie存在于浏览器内存中,浏览器关闭自动销毁 零: 删除对应cookie 存储中文 Cookie不支持存中文, 如果非要存中文可以把中文进行URL编码存进去, 取的时候再解码\nSession 客户端会话技术,基于Cookie实现, 将数据保存在服务端, JavaEE提供了HttpSession接口来实现一次会话多次请求间数据的共享功能\n基本使用 //获取Session对象 HttpSession hs = request.getSession(); //设置session值, 键值对 hs.setAttribute(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;); //根据key获取Session的值 String v = (String) hs.getAttribute(\u0026#34;key\u0026#34;); 钝化 服务端正常关闭后,Tomcat会自动将Session数据写入到硬盘文件中\n活化 服务器启动后,会从文件中加载Session\n销毁 在web.xml配置Session到期时间, 添加下面代码,时间单位: 分钟 \u0026lt;session-config\u0026gt; \u0026lt;session-timeout\u0026gt;30\u0026lt;/session-timeout\u0026gt; \u0026lt;/session-config\u0026gt; 调用Session的 invalidate() 方法销毁 总结 cookie和session都是来完成一次会话多次请求之间的数据共享\n区别：\n存储位置: cookie存储在客户端, session存储在服务端 安全性: cookie不安全, session安全 数据大小: cookie最多3kb, session无大小限制 存储时间: cookie可以无限期存储, session默认30分钟 性能影响: cookie不占用服务器资源, session占用服务器资源 ","permalink":"https://eoezora.github.io/posts/javaweb/javaweb-%E4%BC%9A%E8%AF%9D%E8%B7%9F%E8%B8%AA%E6%8A%80%E6%9C%AF/","summary":"会话 会话:客户端跟服务端的连接,会话建立后直到一方断开连接才会结束.在一次会话中可以包含多次请求和响应 会话跟踪:服务端会识别多个请求是否来自同一个客户端,以便在同次会话的多次请求间共享数据 HTTP协议是无状态的,每次客户端向服务端请求时。服务端都会将该请求视为新的请求,因此我们需要会话跟踪技术来实现会话内数据共享 实现方式: 客户端会话跟踪技术: Cookie 服务端跟会话踪技术: Session Cokkie 客户端会话技术,将数据保存在客户端,以后每次请求都携带Cookie数据进行访问\n基本使用 @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //创建Cookie对象 Cookie cookie = new Cookie(\u0026#34;key\u0026#34;,\u0026#34;value\u0026#34;); //发送cookie到客户端 response.addCookie(cookie); //获取客户端所有cookie Cookie[] cookies = request.getCookies(); //通过遍历获取每个cookie for (Cookie cookie1 : cookies) { System.out.println(cookie1.getName() + \u0026#34; - \u0026#34; + cookie1.getValue()); } } 存活时间 默认情况下, 当浏览器关闭后,内存释放,Cookie会被销毁\n使用方法 cookie.setMaxAge(秒) 设置cookie存活时间\n而参数有以下含义\n正数: 将会cookie写入浏览器所在电脑硬盘,持久化存储到期自动删除 负数: 默认值, Cookie存在于浏览器内存中,浏览器关闭自动销毁 零: 删除对应cookie 存储中文 Cookie不支持存中文, 如果非要存中文可以把中文进行URL编码存进去, 取的时候再解码","title":"JavaWEB笔记-会话跟踪技术"},{"content":"请求的数据格式 数据分为三部分\n请求行: 请求数据第一行, GET/POST 表示请求方式 / 表示请求路径 HTTP/1.1表示协议版本 请求头: 键值对数据 请求体: POST请求的最后一部分, 存放请求参数 例子:\nGET / HTTP/1.1 浏览器能够接受的资源类型 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 浏览器可以支持的压缩类型 Accept-Encoding: gzip, deflate, br 浏览器偏好语言 Accept-Language: en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7 Cache-Control: max-age=0 Connection: keep-alive Cookie: 请求主机名 Host: www.baidu.com Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: none Sec-Fetch-User: ?1 Upgrade-Insecure-Requests: 1 浏览器版本 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36 sec-ch-ua: \u0026#34;Chromium\u0026#34;;v=\u0026#34;106\u0026#34;, \u0026#34;Google Chrome\u0026#34;;v=\u0026#34;106\u0026#34;, \u0026#34;Not;A=Brand\u0026#34;;v=\u0026#34;99\u0026#34; sec-ch-ua-mobile: ?0 sec-ch-ua-platform: \u0026#34;Windows\u0026#34; GET请求参数在请求行中.没有请求体\nPOST请求参数在请求体中\nGET请求有参数大小限制.POST没有\n响应的数据格式 数据分为三部分\n响应行: 响应数据第一行, HTTP/1.1表示协议版本 200 代表响应代码 OK 表示状态描述 响应头: 键值对数据 响应体: 最后一部分, 存放响应数据 HTTP/1.1 200 OK Bdpagetype: 2 Bdqid: 0xeaa6d46b0000e982 客户端如何缓存, 设置 max-age=300 表示最多缓存300秒 Cache-Control: private Connection: keep-alive 响应的压缩算法 Content-Encoding: gzip 响应内容的类型 Content-Type: text/html;charset=utf-8 响应内容长度(字节数) Content-Lenght: 100 Server: BWS/1.1 Set-Cookie: BDSVRTM=318; path=/ Set-Cookie: BD_HOME=1; path=/ Set-Cookie: H_PS_PSSID=37375_36551_37359_36884_37402_37396_37406_36786_37499_26350_37448_37370_37449; path=/; domain=.baidu.com Strict-Transport-Security: max-age=172800 Traceid: 1665032548061897473016908435407035754882 X-Frame-Options: sameorigin X-Ua-Compatible: IE=Edge,chrome=1 Transfer-Encoding: chunked ","permalink":"https://eoezora.github.io/posts/javaweb/javaweb-http/","summary":"请求的数据格式 数据分为三部分\n请求行: 请求数据第一行, GET/POST 表示请求方式 / 表示请求路径 HTTP/1.1表示协议版本 请求头: 键值对数据 请求体: POST请求的最后一部分, 存放请求参数 例子:\nGET / HTTP/1.1 浏览器能够接受的资源类型 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 浏览器可以支持的压缩类型 Accept-Encoding: gzip, deflate, br 浏览器偏好语言 Accept-Language: en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7 Cache-Control: max-age=0 Connection: keep-alive Cookie: 请求主机名 Host: www.baidu.com Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: none Sec-Fetch-User: ?1 Upgrade-Insecure-Requests: 1 浏览器版本 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36 sec-ch-ua: \u0026#34;Chromium\u0026#34;;v=\u0026#34;106\u0026#34;, \u0026#34;Google Chrome\u0026#34;;v=\u0026#34;106\u0026#34;, \u0026#34;Not;A=Brand\u0026#34;;v=\u0026#34;99\u0026#34; sec-ch-ua-mobile: ?0 sec-ch-ua-platform: \u0026#34;Windows\u0026#34; GET请求参数在请求行中.","title":"JavaWEB笔记-HTTP"},{"content":"快速入门 创建web项目,导入servlet坐标\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javax.servlet-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.0.1\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Tomcat 10 使用这个--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;jakarta.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jakarta.servlet-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.0.0\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; 简单使用例\npackage com.eoezora.controller; import jakarta.servlet.ServletException; import jakarta.servlet.annotation.WebServlet; import jakarta.servlet.http.HttpServlet; import jakarta.servlet.http.HttpServletRequest; import jakarta.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(\u0026#34;/test\u0026#34;) // 访问路径是 /test public class TestController extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\u0026#34;get\u0026#34;); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\u0026#34;post\u0026#34;); } } urlPattern配置 Servlet想要被访问,就必须设置其访问路径 (urlPattern)\n一个Servlet可以配置多个urlPattern, 例如 @WebServlet(urlPattern = {\u0026quot;/test1\u0026quot;, \u0026ldquo;/test2\u0026rdquo;, \u0026ldquo;/test3\u0026rdquo;})\nurlPattern配置规则\n优先级: 精确路径匹配 \u0026gt; 目录路径匹配 \u0026gt; 扩展名匹配 \u0026gt; / /*\n精确匹配 @WebServlet(\u0026#34;/user/info\u0026#34;) //访问路径为 -\u0026gt; http://localhost:8080/webapp/user/info 目录匹配 以下面例子来说,只要在/user目录下的请求都能访问该Servlet\n@WebServlet(\u0026#34;/user/*\u0026#34;) //访问路径为 -\u0026gt; http://localhost:8080/webapp/user/aaa | http://localhost:8080/webapp/user/bbb 拓展名匹配 访问该拓展名的文件资源\n@WebServlet(\u0026#34;*.do\u0026#34;) //访问路径为 -\u0026gt; http://localhost:8080/webapp/aaa.do 任意匹配 不管访问地址是啥，都能访问这个Servlet\n@WebServlet(\u0026#34;/\u0026#34;) @WebServlet(\u0026#34;/*\u0026#34;) //访问路径为 -\u0026gt; http://localhost:8080/webapp/abc 可以用任意路径访问这个Servlet //当我们在项目中设置了 \u0026#34;/\u0026#34; 和 \u0026#34;/*\u0026#34; 后会覆盖掉tomcat默认的DefaultServlet.当其他的urlPattern都匹配不上时会访问这个Servlet xml配置Servlet 需要在web.xml中配置, 例子如下, Servlet类与注解方式一样，只是不需要写注解@WebServlet\n\u0026lt;servlet\u0026gt; \u0026lt;!-- servlet名字 --\u0026gt; \u0026lt;servlet-name\u0026gt;test\u0026lt;/servlet-name\u0026gt; \u0026lt;!-- servlet类的路径 --\u0026gt; \u0026lt;servlet-class\u0026gt;com.eoezora.controller.TestController\u0026lt;/servlet-class\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;!-- servlet名字 --\u0026gt; \u0026lt;servlet-name\u0026gt;test\u0026lt;/servlet-name\u0026gt; \u0026lt;!-- servlet访问路径 --\u0026gt; \u0026lt;url-pattern\u0026gt;/test\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; ","permalink":"https://eoezora.github.io/posts/javaweb/javaweb-tomcat/","summary":"快速入门 创建web项目,导入servlet坐标\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javax.servlet-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.0.1\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Tomcat 10 使用这个--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;jakarta.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jakarta.servlet-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.0.0\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; 简单使用例\npackage com.eoezora.controller; import jakarta.servlet.ServletException; import jakarta.servlet.annotation.WebServlet; import jakarta.servlet.http.HttpServlet; import jakarta.servlet.http.HttpServletRequest; import jakarta.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(\u0026#34;/test\u0026#34;) // 访问路径是 /test public class TestController extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\u0026#34;get\u0026#34;); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\u0026#34;post\u0026#34;); } } urlPattern配置 Servlet想要被访问,就必须设置其访问路径 (urlPattern)","title":"JavaWEB笔记-Servlet"},{"content":"简介 AOP: 面向切面编程, 一种编程范式,指导开发者如何组织程序结构\n作用: 在不惊动原始设计的基础上进行功能增强\nSpring理念: 无入侵式\\无侵入式 编程\n代理(Proxy): 本质是采用代理模式实现\n切入点(PointCut): 匹配连接点的式子, 可以理解成共性功能的方法描述\n连接点(JoinPoint): 可以被增强的方法, 可以理解成任意方法\n通知(Advice): 要添加的功能, 共性功能,\n切面(Aspect): 把通知应用到切入点的过程\n目标对象(Target): 被代理的原始对象的目标对象\n简单例子 Spring自带aop相关依赖,这里只需要导入Aspectj即可\n导入Maven坐标 \u0026lt;!--aspectj坐标--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.aspectj\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aspectjweaver\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.9.9.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 通知类 /** * 通知类 * @Aspect 告诉Spring这是个AOP增强 */ @Component @Aspect public class AOPAdvice { /** * 定义一个 \u0026lt;切入点\u0026gt; * @Pointcut 切入点注解 * \u0026#34;execution(void com.eoezora.aop_spring.dao.BookDao.update())\u0026#34; 执行目标包下的某个方法 */ @Pointcut(\u0026#34;execution(void com.eoezora.aop_spring.dao.BookDao.update())\u0026#34;) private void commonUpdate() {} /** * 定义一个 \u0026lt;通知\u0026gt; 方法 * @Before 在方法执行前通知 * @After 在方法执行后通知 * @AfterReturning 放回后通知 * @AfterThrowing 发生异常后通知 * @Around 在方法执行前和执行后通知 */ @Before(\u0026#34;commonUpdate()\u0026#34;) public void commonMethod() { System.out.println(\u0026#34;Now: \u0026#34; + System.currentTimeMillis()); } //环绕方法的使用， 因为无法预测原始方法是否会出异常, 所以这里需要把他抛出去 //获取原始方法相关签名信息 使用point.getSignature(); 可以获取原始代码的类名, 增强的方法名等 @Around(\u0026#34;commonSelect()\u0026#34;) public Object commonMethod(ProceedingJoinPoint point) throws Throwable { System.out.println(\u0026#34;A: \u0026#34; + System.currentTimeMillis()); //原始方法的调用并获取原始方法执行后的的返回值 Object ret = point.proceed(); System.out.println(\u0026#34;B: \u0026#34; + System.currentTimeMillis()); //返回原始方法执行后的返回值 return ret; } } 接口实现类 @Repository public class BookDaoImpl implements BookDao { @Override public void save() { System.out.println(System.currentTimeMillis()); System.out.println(\u0026#34;book save...\u0026#34;); } //\u0026lt;连接点\u0026gt; 方法 @Override public void update() { System.out.println(\u0026#34;book update...\u0026#34;); } @Override public void select() { System.out.println(\u0026#34;book select...\u0026#34;); } } Spring配置类 @Configuration @ComponentScan(\u0026#34;com.eoezora\u0026#34;) @PropertySource(\u0026#34;classpath:jdbc.properties\u0026#34;) //开启aop自动代理 @EnableAspectJAutoProxy public class SpringConfig { } 工作流程 Spring容器启动 读取所有切面配置中的切入点 初始化Bean, 判定Bean对应类中的方法是否匹配到任意切入点 匹配失败: 创建对象 匹配成功: 创建原始对象的代理对象 获取Bean执行方法 获取Bean, 调用方法并执行 获取的Bean是代理对象,根据代理对象的运行模式运行原始方法与增强内容 整个实现过程使用代理模式实现\n切入点表达式 切入点表达式标准格式: 动作关键字(访问修饰符 返回值 包名.类/接口名.方法名(参数) 异常名)\n可以使用通配符描述切入点,快速描述,例如\n//匹配 com.eoezora包下的任意包中的BookDao类或接口中update开头的带头一个任意参数的方法 execution(public * com.eoezora.*.BookDao.update*(*)) //匹配com包下的任意包中的BookDao类或接口中所有update方法 execution(public BookDao com..BookDao.update(..)) // + 用于匹配子类类型, 任意返回值,任意包下的以BookDao结尾的类或接口的子类中的任意方法 execution(* *..*BookDao+.(..)) 获取通知数据 获取参数 JoinPoint: 适用于前置, 后置 返回后, 抛出异常后通知\nProceedJoinPoint: 适用于环绕通知\n获取返回值 返回后通知\n/** * 此方法里带参数,有JoinPoint的话,始终保持第一个参数, 后面接返回的 * returning = \u0026#34;ret\u0026#34; ret是该方法的参数, 也是@AfterReturning返回的原始方法的返回值 */ @AfterReturning(value = \u0026#34;commonTest()\u0026#34;, returning = \u0026#34;ret\u0026#34;) public Object commonMethod(JoinPoint point, Object ret) throws Throwable { return ret; } 环绕通知\n/** * 环绕方法执行原型方法后会返回原始方法的返回值 */ @Around(\u0026#34;commonTest()\u0026#34;) public Object commonMethod(ProceedingJoinPoint point) throws Throwable { //如果原始方法返回100, 则ret就是100 Object ret = point.proceed(); return ret; } 获取异常 抛出异常后通知\n/** * 抛出异常后返回 \u0026#34;异常\u0026#34; */ @AfterThrowing(value = \u0026#34;commonTest()\u0026#34;, throwing = \u0026#34;t\u0026#34;) public void commonMethod(Throwable t) throws Throwable { } 环绕通知\n","permalink":"https://eoezora.github.io/posts/spring/spring-aop%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/","summary":"简介 AOP: 面向切面编程, 一种编程范式,指导开发者如何组织程序结构\n作用: 在不惊动原始设计的基础上进行功能增强\nSpring理念: 无入侵式\\无侵入式 编程\n代理(Proxy): 本质是采用代理模式实现\n切入点(PointCut): 匹配连接点的式子, 可以理解成共性功能的方法描述\n连接点(JoinPoint): 可以被增强的方法, 可以理解成任意方法\n通知(Advice): 要添加的功能, 共性功能,\n切面(Aspect): 把通知应用到切入点的过程\n目标对象(Target): 被代理的原始对象的目标对象\n简单例子 Spring自带aop相关依赖,这里只需要导入Aspectj即可\n导入Maven坐标 \u0026lt;!--aspectj坐标--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.aspectj\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aspectjweaver\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.9.9.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 通知类 /** * 通知类 * @Aspect 告诉Spring这是个AOP增强 */ @Component @Aspect public class AOPAdvice { /** * 定义一个 \u0026lt;切入点\u0026gt; * @Pointcut 切入点注解 * \u0026#34;execution(void com.eoezora.aop_spring.dao.BookDao.update())\u0026#34; 执行目标包下的某个方法 */ @Pointcut(\u0026#34;execution(void com.eoezora.aop_spring.dao.BookDao.update())\u0026#34;) private void commonUpdate() {} /** * 定义一个 \u0026lt;通知\u0026gt; 方法 * @Before 在方法执行前通知 * @After 在方法执行后通知 * @AfterReturning 放回后通知 * @AfterThrowing 发生异常后通知 * @Around 在方法执行前和执行后通知 */ @Before(\u0026#34;commonUpdate()\u0026#34;) public void commonMethod() { System.","title":"JavaWEB笔记-Spring-AOP"},{"content":"简介 事务作用: 在数据层保证一系列数据库操作同时成功或同时失败\nSpring事务作用: 在数据层或业务层的一些列数据库操作同时成功或同时失败\n例子 通过相同的数据源DataSource来管理sql的事务\n在业务层的接口上, 要添加Spring事务的方法上添加注解 @Transactional, 一般是使用在业务层接口上,不会用在实现类上. @Transactional也可以使用在类上,使用在类上表示该类所有方法都开启事务 设置事务管理器 @Bean public PlatformTransactionManager transactionManager(DataSource dataSource) { DataSourceTransactionManager transactionManager = new DataSourceTransactionManager(); transactionManager.setDataSource(dataSource); return transactionManager; } 在Spring设置里打开注解事务驱动 //开起启用注解事务 @EnableTransactionManagement //事务简单例子 //本方法中有三个事务分别是 test_Tran() print_a() print_b() //在实际运行中print_a()和print_b()会加入到test_Tran()中形成一个新的事务, 从而实现print_a()和print_b()的同时成功或同时失败 @Transactional public void test_Tran(){ common.print_a(); //... common.print_b(); } class common { @Transactional public void print_a() { sout(\u0026#34;2333\u0026#34;); } @Transactional public void print_b() { sout(\u0026#34;12345\u0026#34;); } } 事务角色 事务管理员: 发起事务方, 在Spring中通常指代业务开始事务的方法\n事务协调员: 加入事务方, 在Spring中通常指数据层方法,也可以是业务层方法\n在sql中事务是隔离互不影响的, 比如事务T1成功-事务T2失败, 这两都不会回滚,而Spring的事务, 会让指定的事务T1,T2加入自己的事务中成为一个新的事务T3,T3如果执行到某一布出错就会回滚事务,\n事务配置 属性 作用 示例 readOnly 设置事务是否只读 readOnly=true 只读 timeout 设置事务超时时间 timeout=-1 永不超时 rollbackFor 设置事务回滚异常(Class : Class) rollbackFor = (Exception.class) rollbackForClassName 设置事务回滚异常(className : String) rollbackForName=\u0026ldquo;Exception.class\u0026rdquo; noRollbackFor 设置事务不回滚异常(Class : Class) 同上 noRollbackForClassName 设置事务不回滚异常(className : String) 同上 propagation 设置事务传播行为 事务传播行为 传播属性 作用 人话 REQUIRED 如果管理员有事务就加入,没有就新建 拥有此属性的方法,被调用时,调用者有事务此方法就加入到调用者的事务中 REQUIRES_NEW 不管, 管理员有没有事务,都创建一个新事物 拥有此属性的方法,被调用时,调用者不管有没有事务此方法都不加入,自己创建一个新的 SUPPORTS 如果管理员有事务就加入,没有无操作 拥有此属性的方法,,被调用时,调用者有事务就加入,没有就照常运行 NOT_SUPPORTED 不管, 管理员有没有事务, 都不做出操作 拥有此属性的方法,,被调用时,不管调用者有没有事务,此方法都加入 MANDATORY 如果管理员有事务就加入,没有就报错 拥有此属性的方法,要求此方法一定带事务运行 NERVER 如果管理员有事务就报错,没有就无操作 拥有此属性的方法,要求此方法一定不带事务运行 NESTED 创建savePoint, 一旦事务回滚, 事务将回滚到savePoint处,由客户响应提交/回滚 ","permalink":"https://eoezora.github.io/posts/spring/spring-%E4%BA%8B%E5%8A%A1/","summary":"简介 事务作用: 在数据层保证一系列数据库操作同时成功或同时失败\nSpring事务作用: 在数据层或业务层的一些列数据库操作同时成功或同时失败\n例子 通过相同的数据源DataSource来管理sql的事务\n在业务层的接口上, 要添加Spring事务的方法上添加注解 @Transactional, 一般是使用在业务层接口上,不会用在实现类上. @Transactional也可以使用在类上,使用在类上表示该类所有方法都开启事务 设置事务管理器 @Bean public PlatformTransactionManager transactionManager(DataSource dataSource) { DataSourceTransactionManager transactionManager = new DataSourceTransactionManager(); transactionManager.setDataSource(dataSource); return transactionManager; } 在Spring设置里打开注解事务驱动 //开起启用注解事务 @EnableTransactionManagement //事务简单例子 //本方法中有三个事务分别是 test_Tran() print_a() print_b() //在实际运行中print_a()和print_b()会加入到test_Tran()中形成一个新的事务, 从而实现print_a()和print_b()的同时成功或同时失败 @Transactional public void test_Tran(){ common.print_a(); //... common.print_b(); } class common { @Transactional public void print_a() { sout(\u0026#34;2333\u0026#34;); } @Transactional public void print_b() { sout(\u0026#34;12345\u0026#34;); } } 事务角色 事务管理员: 发起事务方, 在Spring中通常指代业务开始事务的方法\n事务协调员: 加入事务方, 在Spring中通常指数据层方法,也可以是业务层方法","title":"JavaWEB笔记-Spring事务"},{"content":"Maven坐标 \u0026lt;!--德鲁伊连接池--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;druid\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.13-SNSAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--数据库连接组件--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--mybatis--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.11\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--spring操作数据库需要的--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-jdbc\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--spring整合mybatis需要的--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-spring\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.7\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; JDBC配置类 public class JDBCConfig { @Value(\u0026#34;${jdbc.url}\u0026#34;) private String url; @Value(\u0026#34;${jdbc.username}\u0026#34;) private String username; @Value(\u0026#34;${jdbc.password}\u0026#34;) private String password; private String driverClass = \u0026#34;com.mysql.jdbc.Driver\u0026#34;; @Bean public DataSource dataSource() { DruidDataSource druidDataSource = new DruidDataSource(); druidDataSource.setDriverClassName(driverClass); druidDataSource.setUrl(url); druidDataSource.setUsername(username); druidDataSource.setPassword(password); return druidDataSource; } } Mybatis配置类 public class MybatisConfig { @Bean public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource) { //创建SqlSessionFactoryBean SqlSessionFactoryBean sfb = new SqlSessionFactoryBean(); //设置mybatis别名扫描 sfb.setTypeAliasesPackage(\u0026#34;com.eoezora.spring_mybatis.domain\u0026#34;); //设置数据源 sfb.setDataSource(dataSource); return sfb; } @Bean public MapperScannerConfigurer mapperScannerConfigurer() { //创建映射文件配置MapperScannerConfigurer MapperScannerConfigurer msc = new MapperScannerConfigurer(); //设置映射文件所在的包路径 msc.setBasePackage(\u0026#34;com.eoezora.spring_mybatis.dao\u0026#34;); return msc; } } Spring配置类 @Configuration @ComponentScan(\u0026#34;com.eoezora.spring_mybatis\u0026#34;) @PropertySource(\u0026#34;classpath:jdbc.properties\u0026#34;) @Import({MybatisConfig.class, JDBCConfig.class}) public class SpringConfig { } 至此Spring和Mybatis整和完毕\n","permalink":"https://eoezora.github.io/posts/spring/spring-%E6%95%B4%E5%90%88mybatis/","summary":"Maven坐标 \u0026lt;!--德鲁伊连接池--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;druid\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.13-SNSAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--数据库连接组件--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--mybatis--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.11\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--spring操作数据库需要的--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-jdbc\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--spring整合mybatis需要的--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-spring\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.7\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; JDBC配置类 public class JDBCConfig { @Value(\u0026#34;${jdbc.url}\u0026#34;) private String url; @Value(\u0026#34;${jdbc.username}\u0026#34;) private String username; @Value(\u0026#34;${jdbc.password}\u0026#34;) private String password; private String driverClass = \u0026#34;com.mysql.jdbc.Driver\u0026#34;; @Bean public DataSource dataSource() { DruidDataSource druidDataSource = new DruidDataSource(); druidDataSource.setDriverClassName(driverClass); druidDataSource.setUrl(url); druidDataSource.setUsername(username); druidDataSource.setPassword(password); return druidDataSource; } } Mybatis配置类 public class MybatisConfig { @Bean public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource) { //创建SqlSessionFactoryBean SqlSessionFactoryBean sfb = new SqlSessionFactoryBean(); //设置mybatis别名扫描 sfb.","title":"JavaWEB笔记-Spring整合mybatis"},{"content":"介绍 Request: 获取请求数据 Response: 设置响应数据 Request 获取请求数据 一些需要了解的方法\n@Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // http://localhost:8080/EoeWebDemo_war/test?username=aas\u0026amp;password=1234567 // 请求行的数据 req.getMethod(); // GET 提交方法 req.getContextPath(); // EoeWebDemo_war 虚拟路径 req.getRequestURL(); // http://localhost:8080/EoeWebDemo_war/test req.getRequestURI(); // /EoeWebDemo_war/test req.getQueryString(); // username=aas\u0026amp;password=1234567 //请求头的数据, 根据请求头名称获取值 req.getHeader(\u0026#34;User-Agent\u0026#34;); //Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36 } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //获取POST请求体的数据 //获取流对象 // BufferedReader getReader()：获取字符输入流 只能操作字符数据 // ServletInputStream getInputStream()：获取字节输入流 可以操作所有类型数据 req.getInputStream(); req.getReader(); } Reuqest提供的获取参数的方法,不管是get还是post都通用\n//获取所有参数 Map\u0026lt;String, String[]\u0026gt; stringMap = req.getParameterMap(); //获取指定参数名的多个值 String[] pars = req.getParameterValues(\u0026#34;某个参数名\u0026#34;); //获取指定参数的单个值 String par = req.getParameter(\u0026#34;某个参数名\u0026#34;); 中文参数乱码解决方式 浏览器对url中的中文会进行URL编码,而Tomcat在解码时使用的字符集是ISO-8859-1, 会导致中文乱码.\n//POST请求直接使用这个方法设置即可 req.setCharacterEncoding(\u0026#34;UTF-8\u0026#34;); //GET请求需要我们手动对字符串进行编码解码操作 //把收到的字符串转为二进制 byte[] bytes = req.getParameter(\u0026#34;参数名\u0026#34;).getBytes(); //在用utf8字符集把二进制数据转成String String newParame = new String(bytes, StandardCharsets.UTF_8); 请求转发 一种服务器内部资源跳转方式\n特点\n浏览器地址栏不会发生变化 转发只能转到服务器内部资源 转发是一次请求,可以使用request共享数据 //转发资源间共享数据方式 request.setAttribute(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;); request.getAttribute(\u0026#34;key\u0026#34;); request.removeAttribute(\u0026#34;key\u0026#34;); //请求转发 request.getRequestDispatcher(\u0026#34;其他资源的访问路径\u0026#34;).forward(request,response); Response 一些方法\n@Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //设置响应代码 response.setStatus(200); //设置响应头 response.setHeader(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;); //获取字符输出流 response.getWriter(); //获取字节输出流 response.getOutputStream(); } Response重定向 介绍：一种资源跳转方式\n特点\n地址栏路径发生变化 可以重定向到任意位置资源, 服务器内部, 外部都可 两次请求,不能在多个资源共享数据 实现方式\n//设置重定向代码 response.setStatus(302); //设置重定向路径 //需要添加request.getContextPath()虚拟目录 response.setHeader(\u0026#34;Location\u0026#34;, request.getContextPath() + \u0026#34;/ts\u0026#34;); //简化方式, 使用这个 response.sendRedirect(request.getContextPath() + \u0026#34;/ts\u0026#34;); 响应字符数据 //response.setHeader(\u0026#34;Content-Type\u0026#34;,\u0026#34;text/html\u0026#34;); response.setContentType(\u0026#34;text/html;charset=utf-8\u0026#34;); PrintWriter pw = response.getWriter(); pw.write(\u0026#34;aaaaa\u0026#34;); pw.write(\u0026#34;\u0026lt;h1\u0026gt;aaaaa\u0026lt;/h1\u0026gt;\u0026#34;); //响应完成后, response 会被销毁, PrintWriter会被服务器关闭 //响应字节流数据 FileInputStream fileInputStream = new FileInputStream(\u0026#34;/bg.jpg\u0026#34;); ServletOutputStream out = response.getOutputStream(); byte[] buffer = new byte[1024]; while ((lenght = fileInputStream.read(buffer)) != -1) { out.write(buffer,0,lenght); } fileInputStream.close(); ","permalink":"https://eoezora.github.io/posts/javaweb/javaweb-%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94/","summary":"介绍 Request: 获取请求数据 Response: 设置响应数据 Request 获取请求数据 一些需要了解的方法\n@Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // http://localhost:8080/EoeWebDemo_war/test?username=aas\u0026amp;password=1234567 // 请求行的数据 req.getMethod(); // GET 提交方法 req.getContextPath(); // EoeWebDemo_war 虚拟路径 req.getRequestURL(); // http://localhost:8080/EoeWebDemo_war/test req.getRequestURI(); // /EoeWebDemo_war/test req.getQueryString(); // username=aas\u0026amp;password=1234567 //请求头的数据, 根据请求头名称获取值 req.getHeader(\u0026#34;User-Agent\u0026#34;); //Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36 } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //获取POST请求体的数据 //获取流对象 // BufferedReader getReader()：获取字符输入流 只能操作字符数据 // ServletInputStream getInputStream()：获取字节输入流 可以操作所有类型数据 req.","title":"JavaWEB笔记-请求和响应"},{"content":"概念 Filter过滤器,是JavaWeb三大组件之一(Servlet, Filter, Listener) 过滤器可以把资源拦截下来,从而实现一些需求 过滤器一般完成一些通用操作,如访问权限控制, 统一编码处理, 铭感字符处理等 快速入门 定义类,实现Filter接口，重写所有方法\npublic class FilterDemo implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { Filter.super.init(filterConfig); } @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { } @Override public void destroy() { Filter.super.destroy(); } } 配置Filter拦截路径, 使用@WebFilter注解\n@WebFilter(\u0026#34;/*\u0026#34;) //表示拦截所有访问 public class FilterDemo implements Filter { } 放行\n@Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { //放行前逻辑 //对request进行处理 //放行请求 chain.doFilter(request,response); //放行后逻辑 //对response进行处理 } 过滤器执行过程 过滤器拦截 -\u0026gt; 执行放行前逻辑 -\u0026gt; 放行 -\u0026gt; 访问资源 -\u0026gt; 回到过滤器 -\u0026gt; 执行放行后逻辑\n使用细节 拦截路径配置 拦截具体资源: /index.html 只有访问/index.html才会拦截 目录拦截: /user/* 访问/user目录下的所有资源都会被拦截 后缀名拦截: *.html 访问后缀为html都会被拦截 拦截所有: /* 所有访问都会被拦截 过滤器链 可以配置多个过滤器, 串成一个过滤器链\n执行顺序: 多个过滤器以过滤器类名自然排序, 例如: AFilter1 BFilter3 Filter2\n放行逻辑执行顺序: 如下图所示,请求先从左到右执行放行前逻辑直到访问资源, 再从右到左访问放行后逻辑\n","permalink":"https://eoezora.github.io/posts/javaweb/javaweb-filter%E8%BF%87%E6%BB%A4%E5%99%A8/","summary":"概念 Filter过滤器,是JavaWeb三大组件之一(Servlet, Filter, Listener) 过滤器可以把资源拦截下来,从而实现一些需求 过滤器一般完成一些通用操作,如访问权限控制, 统一编码处理, 铭感字符处理等 快速入门 定义类,实现Filter接口，重写所有方法\npublic class FilterDemo implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { Filter.super.init(filterConfig); } @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { } @Override public void destroy() { Filter.super.destroy(); } } 配置Filter拦截路径, 使用@WebFilter注解\n@WebFilter(\u0026#34;/*\u0026#34;) //表示拦截所有访问 public class FilterDemo implements Filter { } 放行\n@Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { //放行前逻辑 //对request进行处理 //放行请求 chain.","title":"JavaWEB笔记-过滤器"},{"content":"增删改查例子 AccountMapper.xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;!-- namespace是映射接口的路径 --\u0026gt; \u0026lt;mapper namespace=\u0026#34;com.eoezora.mybatisDemo.mapper.AccountMapper\u0026#34;\u0026gt; \u0026lt;!-- 添加数据, 参数POJO -\u0026gt; EoeAccount --\u0026gt; \u0026lt;!-- 添加这两个 useGeneratedKeys=\u0026#34;true\u0026#34; keyProperty=\u0026#34;id\u0026#34; 属性在insert标签里可以返回主键 --\u0026gt; \u0026lt;insert id=\u0026#34;addAccount\u0026#34; useGeneratedKeys=\u0026#34;true\u0026#34; keyProperty=\u0026#34;id\u0026#34;/\u0026gt; \u0026lt;insert id=\u0026#34;addAccount\u0026#34; \u0026gt; INSERT INTO account (name, age, brithDay, location) \u0026lt;!-- 这里的名字要与POJO类力的变量名一致 --\u0026gt; VALUES (#{name},#{age},#{brithDay},#{location}); \u0026lt;/insert\u0026gt; \u0026lt;!-- 删除一条数据 --\u0026gt; \u0026lt;delete id=\u0026#34;delAccouintById\u0026#34;\u0026gt; DELETE FROM account WHERE id = #{id} \u0026lt;/delete\u0026gt; \u0026lt;!-- 删除多条数据 --\u0026gt; \u0026lt;delete id=\u0026#34;delAccouintByIds\u0026#34;\u0026gt; DELETE FROM account WHERE id in \u0026lt;!-- collection需要遍历的集合 item 集合里的元素 separator 分隔符 open 前缀符 close 后缀符 --\u0026gt; \u0026lt;foreach collection=\u0026#34;ids\u0026#34; item=\u0026#34;id\u0026#34; separator=\u0026#34;,\u0026#34; open=\u0026#34;(\u0026#34; close=\u0026#34;)\u0026#34;\u0026gt; #{id} \u0026lt;/foreach\u0026gt; \u0026lt;/delete\u0026gt; \u0026lt;!-- 查询所以数据 多个条件使用 and 分割 --\u0026gt; \u0026lt;select id=\u0026#34;selectAccounts\u0026#34; resultType=\u0026#34;com.eoezora.mybatisDemo.pojo.EoeAccount\u0026#34;\u0026gt; SELECT * FROM account; \u0026lt;/select\u0026gt; \u0026lt;!-- 根据ID查询数据 --\u0026gt; \u0026lt;select id=\u0026#34;selectAccount\u0026#34; parameterType=\u0026#34;int\u0026#34; resultType=\u0026#34;com.eoezora.mybatisDemo.pojo.EoeAccount\u0026#34;\u0026gt; SELECT * FROM account WHERE id = #{id}; \u0026lt;/select\u0026gt; \u0026lt;!-- 根据ID修改数据 --\u0026gt; \u0026lt;!-- 动态修改参考动态查询 --\u0026gt; \u0026lt;update id=\u0026#34;setAccountAge\u0026#34;\u0026gt; UPDATE account SET age = #{age} WHERE id = #{id} \u0026lt;/update\u0026gt; \u0026lt;/mapper\u0026gt; AccountMapper.class package com.eoezora.mybatisDemo.mapper; import com.eoezora.mybatisDemo.pojo.EoeAccount; import java.util.List; //映射接口, 方法名与上方SQL映射xml里的ID一致 public interface AccountMapper { /** * \u0026lt;insert id=\u0026#34;addAccount\u0026#34; parameterType=\u0026#34;com.eoezora.mybatisDemo.pojo.EoeAccount\u0026#34;\u0026gt; **/ void addAccount(EoeAccount eoeAccount); /** * \u0026lt;select id=\u0026#34;selectAccounts\u0026#34; resultType=\u0026#34;com.eoezora.mybatisDemo.pojo.EoeAccount\u0026#34;\u0026gt; **/ List\u0026lt;EoeAccount\u0026gt; selectAccounts(); /** * \u0026lt;select id=\u0026#34;selectAccount\u0026#34; parameterType=\u0026#34;int\u0026#34; resultType=\u0026#34;com.eoezora.mybatisDemo.pojo.EoeAccount\u0026#34;\u0026gt; **/ EoeAccount selectAccount(@Param(\u0026#34;id\u0026#34;)int id); /** * \u0026lt;delete id=\u0026#34;delAccouintById\u0026#34;\u0026gt; **/ void delAccouintById(@Param(\u0026#34;id\u0026#34;)int id); /** * \u0026lt;delete id=\u0026#34;delAccouintByIds\u0026#34;\u0026gt; 传入数组批量删除多条数据 **/ void delAccouintById(@Param(\u0026#34;ids\u0026#34;) int[] id); //传递参数的三种方式 /** * 多个单独的参数, @Param里的值与xml映射表的占位符一致,也就是与 xml 里的 #{} 里的一致 例如: #{name} **/ List\u0026lt;EoeAccount\u0026gt; selectAccountByCondition(@Param(\u0026#34;name\u0026#34;) String name, @Param(\u0026#34;age\u0026#34;) intn age); /** * 如果参数可以封装在同一个类里,也可以直接传一个对象过来. xml #{} 将使用该对象参数名作为占位符 **/ List\u0026lt;EoeAccount\u0026gt; selectAccountByCondition(EoeAccount account); /** * HashMap key -\u0026gt; value * - 占位符名称 -\u0026gt; 数值 **/ List\u0026lt;EoeAccount\u0026gt; selectAccountByCondition(Map map); /** * 使用注解查询, 一般使用在简单的sql语句上, 复杂的语句还是使用xml映射 **/ @Select(\u0026#34;SELECT * FROM account WHERE id = #{id}\u0026#34;) EoeAccount selectAccount(int id); } 使用接口进行增删改查 try (SqlSession session = sqlSessionFactory.openSession()) { AccountMapper mapper = session.getMapper(AccountMapper.class); mapper.selectAccounts(); mapper.addAccount(); //需要注意的是 mybatis 对数据库进行增删改的操作后需要手动提交 session.commit(); } /** * 获取主键 * 当数据添加完成后, 若insert标签有设置useGeneratedKeys=\u0026#34;true\u0026#34; keyProperty=\u0026#34;id\u0026#34; 属性 * 则可以根据 以下方式获取返回的主键id **/ EoeAccount ea = new EoeAccount(\u0026#34;蔡某\u0026#34;,25,\u0026#34;1919-08-10\u0026#34;,\u0026#34;荔枝星\u0026#34;); mapper.addAccount(ea); System.out.println(ea.getId()); 多条件动态查询 在根据条件查询时,多个条件使用以下方式,传入的条件参数是固定的。比如下面这条是3个.\n\u0026lt;!-- 查询所以数据 多个条件使用 and 分割 --\u0026gt; \u0026lt;select id=\u0026#34;selectAccounts\u0026#34; resultType=\u0026#34;com.eoezora.mybatisDemo.pojo.EoeAccount\u0026#34;\u0026gt; SELECT * FROM account WHERE id = 1 AND name = \u0026#39;xxx\u0026#39; AND AGE = 24; \u0026lt;/select\u0026gt; 有时候我们需要的是模糊查询, 用户给的条件数量是不固定的，有时一个有时三个。我们需要根据传来的条件参数数量来动态调整我们的SQL语句。MyBatis提供了许多标签来支持此功能: if | choose(when, otherwise) | trim(where, set) | foreach\n\u0026lt;select id=\u0026#34;selectAccounts\u0026#34; resultType=\u0026#34;com.eoezora.mybatisDemo.pojo.EoeAccount\u0026#34;\u0026gt; SELECT * FROM account \u0026lt;!-- 使用where标签可以解决第一个条件不存在时的报错, 同时会帮我们去掉多余的AND --\u0026gt; \u0026lt;!-- 下面为例 当id小于0，条件不会被拼到sql语句里,且会帮我们去掉name前面的AND --\u0026gt; \u0026lt;where\u0026gt; \u0026lt;!-- test后面跟判断条件 --\u0026gt; \u0026lt;if test=\u0026#34;id \u0026gt; 0\u0026#34;\u0026gt; AND id = #{id} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;name != null\u0026#34;\u0026gt; AND name LIKE #{name} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;age \u0026gt; 0\u0026#34;\u0026gt; AND age = #{age} \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; 单条件动态查询 当我们需要单条件动态查询时，使用以下方法\n\u0026lt;select id=\u0026#34;selectAccounts\u0026#34; resultType=\u0026#34;com.eoezora.mybatisDemo.pojo.EoeAccount\u0026#34;\u0026gt; SELECT * FROM account \u0026lt;where\u0026gt; \u0026lt;choose\u0026gt;\u0026lt;!-- 类似switch --\u0026gt; \u0026lt;when test=\u0026#34;id \u0026gt; 0\u0026#34;\u0026gt;\u0026lt;!-- 类似case --\u0026gt; id = #{id} \u0026lt;/when\u0026gt; \u0026lt;when test=\u0026#34;name != null and name != \u0026#39;\u0026#39;\u0026#34;\u0026gt; name like #{name} \u0026lt;/when\u0026gt; \u0026lt;when test=\u0026#34;age \u0026gt; 0\u0026#34;\u0026gt; age = #{age} \u0026lt;/when\u0026gt; \u0026lt;otherwise\u0026gt;1 = 1\u0026lt;/otherwise\u0026gt;\u0026lt;!-- 类似default 使用where标签可以去掉这个 --\u0026gt; \u0026lt;/choose\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; 参数传递 Mybatis接口方法可以接受各种各样的参数，底层会对这些参数进行不同的封装处理\n单个参数: POJO类型\nMap集合\nCoolection\nList\nArray\n其他类型\n多个参数: 类似EoeAccount selectAccount(@Param(\u0026ldquo;id\u0026rdquo;)int id, @Param(\u0026ldquo;name\u0026rdquo;)String name\u0026hellip;); 参数需要有@Param注解,里面的值与xml映射文件里的占位符一致\n#:D 参数占位符 #{}: 执行SQL时, 会将#{}占位符替换成 ? 会自动设置参数, 防止sql注入\n${}: 拼SQL语句,会出现sql注入问题.\n一般在传参数时使用 #{} 在对表名，列名进行动态设置时，使用${} 进行拼接.\nparameterType 用于设置传入的参数类型, 此属性可以省略\nresultType 执行SQL语句后返回的数据进行封装，此属性指定封装后的类型\nxml中特殊字符处理 在xml文件写SQL语句时难免会出现 大于小于的判断 而 \u0026lt; 是xml标签起始。所以需要进行处理。下面为例子\n\u0026lt;select id=\u0026#34;selectAccount\u0026#34; parameterType=\u0026#34;int\u0026#34; resultType=\u0026#34;com.eoezora.mybatisDemo.pojo.EoeAccount\u0026#34;\u0026gt; SELECT * FROM account \u0026lt;!-- 此处的小于号 \u0026lt; 会报错, 因为被xml判定成了不完成的标签 --\u0026gt; WHERE id \u0026lt; 5; \u0026lt;/select\u0026gt; \u0026lt;!-- 正确的写法应该是 CDATA 或者 转义字符 --\u0026gt; \u0026lt;select id=\u0026#34;selectAccount\u0026#34; parameterType=\u0026#34;int\u0026#34; resultType=\u0026#34;com.eoezora.mybatisDemo.pojo.EoeAccount\u0026#34;\u0026gt; SELECT * FROM account WHERE id \u0026lt;!-- 把他也输符号写在CDATA 里就不会报错了 --\u0026gt; \u0026lt;![CDATA[ \u0026lt; ]]\u0026gt; #{id}; \u0026lt;/select\u0026gt; ","permalink":"https://eoezora.github.io/posts/mybatis/mybatis-%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/","summary":"增删改查例子 AccountMapper.xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;!-- namespace是映射接口的路径 --\u0026gt; \u0026lt;mapper namespace=\u0026#34;com.eoezora.mybatisDemo.mapper.AccountMapper\u0026#34;\u0026gt; \u0026lt;!-- 添加数据, 参数POJO -\u0026gt; EoeAccount --\u0026gt; \u0026lt;!-- 添加这两个 useGeneratedKeys=\u0026#34;true\u0026#34; keyProperty=\u0026#34;id\u0026#34; 属性在insert标签里可以返回主键 --\u0026gt; \u0026lt;insert id=\u0026#34;addAccount\u0026#34; useGeneratedKeys=\u0026#34;true\u0026#34; keyProperty=\u0026#34;id\u0026#34;/\u0026gt; \u0026lt;insert id=\u0026#34;addAccount\u0026#34; \u0026gt; INSERT INTO account (name, age, brithDay, location) \u0026lt;!-- 这里的名字要与POJO类力的变量名一致 --\u0026gt; VALUES (#{name},#{age},#{brithDay},#{location}); \u0026lt;/insert\u0026gt; \u0026lt;!-- 删除一条数据 --\u0026gt; \u0026lt;delete id=\u0026#34;delAccouintById\u0026#34;\u0026gt; DELETE FROM account WHERE id = #{id} \u0026lt;/delete\u0026gt; \u0026lt;!-- 删除多条数据 --\u0026gt; \u0026lt;delete id=\u0026#34;delAccouintByIds\u0026#34;\u0026gt; DELETE FROM account WHERE id in \u0026lt;!","title":"JavaWEB笔记-MyBatis-增删改查"},{"content":"简介: 一个用于数据持久层的框架\n基本配置 //mybatis配置文件 String resource = \u0026#34;mybatis-config.xml\u0026#34;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); try (SqlSession session = sqlSessionFactory.openSession()) { //此处是直接调用方法进行操作，建议使用代理开发 List\u0026lt;EoeAccount\u0026gt; datas = session.selectList(\u0026#34;test.selectAll\u0026#34;); datas.forEach(System.out::println); session.close(); } Mybatis配置文件(mybatis-config.xml)\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;https://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;environment id=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;/\u0026gt; \u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/eoezora?useSSL=false\u0026amp;amp;allowPublicKeyRetrieval=true\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper resource=\u0026#34;mappers/TestDemoMapper.xml\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;/configuration\u0026gt; SQL语句\n映射文件(TestDemoMapper.xml)\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;!-- 代理开发中 namespace的值应该是 Mapper接口的全限定名 --\u0026gt; \u0026lt;!-- 例如 com.eoezora.mapper.TestDemoMapper --\u0026gt; \u0026lt;mapper namespace=\u0026#34;test\u0026#34;\u0026gt; \u0026lt;!-- resultType 返回值 --\u0026gt; \u0026lt;select id=\u0026#34;selectAll\u0026#34; resultType=\u0026#34;com.eoezora.pojo.EoeAccount\u0026#34;\u0026gt; SELECT * FROM account; \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; Mapper代理开发 定义与SQL映射文件同名的Mapper接口,并且将Mapper接口与SQL映射文件放置在同名文件下\n设置SQL映射文件的namespace属性与Mapper接口全限定名\n在Mapper接口中定义方法,方法名是SQL映射文件中的sql语句ID，并保持参数类型和返回值类型一致\ntry (SqlSession session = sqlSessionFactory.openSession()) { //获取Mapper接口 TestDemoMapper testDemoMapper = session.getMapper(TestDemoMapper.class); //使用接口调用方法 testDemoMapper.selectAll().forEach(System.out::println); } 设置别名 在Nybatis的sql的映射文件中,会使用paramterType、resultType 来设置 sql 语句的输入输出参数，一般参数都是基本的数据类型或封装类型，但都需要声明该类型的全路径，java.lang.String，或者 cn.com.mybatis.pojo.User, 这时就可以通过 typeAliases设置别名,简化复杂度，提高阅读性, 例子如下\n\u0026lt;select id=\u0026#34;selectUserByName\u0026#34; parameterType=\u0026#34;java.lang.String\u0026#34; resultType=\u0026#34;com.mybatis.pojo.User\u0026#34;\u0026gt; SELECT * FROM USER WHERE username LIKE \u0026#39;%${value}%\u0026#39; \u0026lt;/select\u0026gt; 使用别名简化后\n\u0026lt;typeAliases\u0026gt; \u0026lt;typeAlias alias=\u0026#34;user\u0026#34; type=\u0026#34;com.mybatis.pojo.User\u0026#34;/\u0026gt; \u0026lt;typeAlias alias=\u0026#34;string\u0026#34; type=\u0026#34;java.lang.String\u0026#34;/\u0026gt; \u0026lt;/typeAliases\u0026gt; \u0026lt;!-- paramterType、resultType直接使用别名 --\u0026gt; \u0026lt;select id=\u0026#34;selectUserByName\u0026#34; parameterType=\u0026#34;string\u0026#34; resultType=\u0026#34;user\u0026#34;\u0026gt; SELECT * FROM USER WHERE username LIKE \u0026#39;%${value}%\u0026#39; \u0026lt;/select\u0026gt; 其他\n批量添加别名,以下设置,会为该包下的所有类自动添加别名,为对应类名的首字母小写 User -\u0026gt; user\n\u0026lt;typeAliases\u0026gt; \u0026lt;package name=\u0026#34;com.mybatis.pojo\u0026#34;/\u0026gt; \u0026lt;/typeAliases ","permalink":"https://eoezora.github.io/posts/mybatis/mybatis/","summary":"简介: 一个用于数据持久层的框架\n基本配置 //mybatis配置文件 String resource = \u0026#34;mybatis-config.xml\u0026#34;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); try (SqlSession session = sqlSessionFactory.openSession()) { //此处是直接调用方法进行操作，建议使用代理开发 List\u0026lt;EoeAccount\u0026gt; datas = session.selectList(\u0026#34;test.selectAll\u0026#34;); datas.forEach(System.out::println); session.close(); } Mybatis配置文件(mybatis-config.xml)\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;https://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;environment id=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;/\u0026gt; \u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/eoezora?useSSL=false\u0026amp;amp;allowPublicKeyRetrieval=true\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper resource=\u0026#34;mappers/TestDemoMapper.xml\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;/configuration\u0026gt; SQL语句","title":"JavaWEB笔记-MyBatis快速入门笔记"},{"content":"简介\n","permalink":"https://eoezora.github.io/posts/mybatis/mybatis-%E9%85%8D%E7%BD%AE/","summary":"简介","title":"JavaWEB笔记-MyBatis配置文件"},{"content":"DriverManager //创建一个链接 String url = \u0026#34;jdbc:mysql://localhost/database?useSSL=false\u0026amp;allowPublicKeyRetrieval=true\u0026#34;; String user = \u0026#34;\u0026#34;; String pwd = \u0026#34;\u0026#34;; Connection connection = DriverManager.getConnection(url,user,pwd); Connection 用于获取执行SQL的对象和管理事务\n//创建链接 Connection connection = DriverManager.getConnection(url,user,pwd); //要执行的SQL语句 String sql = \u0026#34;UPDATE users SET money = 1000 WHERE id = 114514;\u0026#34;; //创建执行对象 Statement statement = connection.createStatement(); try { //开启事务 connection.setAutoCommit(false); //执行语句 statement.executeUpdate(sql); //事务提交 connection.commit(); } catch (Exception e) { //若执行失败则回滚事务 connection.rollback(); throw new RuntimeException(e); } Statement 作用：执行SQL语句\n//执行DML DDL 语句， 增删改，返回受影响的行数 int executeUpdate(String sql) //执行DQL语句 返回ResultSet结果集对象,查询语句 ResultSet executeQuery(String sql) ResultSet 作用：一个结果集对象，封装了DQL查询语句的结果\n//执行DQL语句返回ResultSet对象 ResultSet rs = statement.executeQuery(sql); //将光标从当前位置往前移动一行，判断当前是否为有效行 boolean next(); //true 有效行，当前行有数据 | 无效行 当前行无数据 //获取数据 //数据类型 get数据类型(参数); String getString(int index); //获取字段名 name 的值 ResultSet rs = statement.executeQuery(sql); while (rs.next()) { System.out.println(rs.getString(\u0026#34;name\u0026#34;)); } PreparedStatement 作用：预编译SQL语句并执行，预防SQL注入问题\nSQL注入是通过操作输入来修改事先定义号的SQL语句，用以达到攻击服务器的作用\nConnection connection = DriverManager.getConnection(url,user,pwd); String sql = \u0026#34;SELECT * FROM goods WHERE id = ?\u0026#34;; //获取预编译Sql对象 PreparedStatement ps = connection.prepareStatement(sql); //设置 ？的参数值 //参数位置 | 参数值 ps.setInt(1,1); //执行语句 ResultSet rs = ps.executeQuery(); rs.next(); System.out.println(rs.getString(\u0026#34;name\u0026#34;)); ","permalink":"https://eoezora.github.io/posts/jdbc-note/api%E8%AF%A6%E8%A7%A3/","summary":"DriverManager //创建一个链接 String url = \u0026#34;jdbc:mysql://localhost/database?useSSL=false\u0026amp;allowPublicKeyRetrieval=true\u0026#34;; String user = \u0026#34;\u0026#34;; String pwd = \u0026#34;\u0026#34;; Connection connection = DriverManager.getConnection(url,user,pwd); Connection 用于获取执行SQL的对象和管理事务\n//创建链接 Connection connection = DriverManager.getConnection(url,user,pwd); //要执行的SQL语句 String sql = \u0026#34;UPDATE users SET money = 1000 WHERE id = 114514;\u0026#34;; //创建执行对象 Statement statement = connection.createStatement(); try { //开启事务 connection.setAutoCommit(false); //执行语句 statement.executeUpdate(sql); //事务提交 connection.commit(); } catch (Exception e) { //若执行失败则回滚事务 connection.rollback(); throw new RuntimeException(e); } Statement 作用：执行SQL语句\n//执行DML DDL 语句， 增删改，返回受影响的行数 int executeUpdate(String sql) //执行DQL语句 返回ResultSet结果集对象,查询语句 ResultSet executeQuery(String sql) ResultSet 作用：一个结果集对象，封装了DQL查询语句的结果","title":"JavaWEB笔记-JDBC-API详解"},{"content":"简介: 数据库连接池是个容器, 负责分配, 管理数据库链接, 允许应用程序重复使用现有的数据库链接, 而不是重新建立一个新连接\n标准接口: DataSource\nDruid配置文件 url=jdbc:mysql:///eoezora?useSSL=false\u0026amp;allowPublicKeyRetrieval=true username=root password=root #初始化连接数量 initialSize=5 #最大连接数 maxActive=10 #最大等待时间 ms maxWait=3000 加载配置 //1.加载配置文件 Properties pro = new Properties(); InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream(\u0026#34;druid.properties\u0026#34;); pro.load(is); //2.获取连接池对象 DataSource ds = DruidDataSourceFactory.createDataSource(pro); //3.获取连接 Connection conn = ds.getConnection(); 归还连接|释放资源 public static void close(ResultSet rs, Statement stmt, Connection conn){ if (rs!=null) { try { rs.close(); } catch (Exception e) { System.out.println(e.getMessage()); } } if (stmt!=null) { try { stmt.close(); } catch (Exception e) { System.out.println(e.getMessage()); } } if (conn!=null){ try { conn.close();//归还连接 } catch (Exception e) { System.out.println(e.getMessage()); } } } ","permalink":"https://eoezora.github.io/posts/jdbc-note/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/","summary":"简介: 数据库连接池是个容器, 负责分配, 管理数据库链接, 允许应用程序重复使用现有的数据库链接, 而不是重新建立一个新连接\n标准接口: DataSource\nDruid配置文件 url=jdbc:mysql:///eoezora?useSSL=false\u0026amp;allowPublicKeyRetrieval=true username=root password=root #初始化连接数量 initialSize=5 #最大连接数 maxActive=10 #最大等待时间 ms maxWait=3000 加载配置 //1.加载配置文件 Properties pro = new Properties(); InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream(\u0026#34;druid.properties\u0026#34;); pro.load(is); //2.获取连接池对象 DataSource ds = DruidDataSourceFactory.createDataSource(pro); //3.获取连接 Connection conn = ds.getConnection(); 归还连接|释放资源 public static void close(ResultSet rs, Statement stmt, Connection conn){ if (rs!=null) { try { rs.close(); } catch (Exception e) { System.out.println(e.getMessage()); } } if (stmt!=null) { try { stmt.","title":"JavaWEB笔记-JDBC-连接池"},{"content":"多表查询 连接查询 内连接 获取两表的交集数据\n-- 隐式写法 SELECT 字段列表 FROM 表1, 表2... WHERE 条件; -- 显示写法 SELECT 字段列表 FROM 表1 INNER JOIN 表2 ON 条件 外连接 左外连接: 相当于查询A表所有数据和交集部分的数据\n右外连接: 相当于查询B表所有数据和交集部分的数据\n-- 左外连接 SELECT 字段列表 FROM 表1 LEFT OUTER JOIN 表2 ON 条件 -- 右外连接 SELECT 字段列表 FROM 表1 RIGHT OUTER JOIN 表2 ON 条件 子查询 概念：查询中嵌套查询,根据查询结果不同，作用不同分为 单行单列，多行单列，多行多列\n-- 单行单列: 作为条件值 使用 = != \u0026gt; \u0026lt; 进行条件判断 SELECT 字段列表 FROM 表 WHERE 字段名 = (子查询语句); -- 多行单列: 作为条件值 SELECT 字段列表 FROM 表 WHERE 字段名 IN (子查询语句); -- 多行多列: 作为虚拟表 SELECT 字段列表 FROM (子查询语句) WHERE 条件; -- 例子 查询工资大于 蔡徐坤 的数据 SELECT name FROM users WHERE money \u0026gt; (SELECT money FROM infos WHERE name = \u0026#34;蔡徐坤\u0026#34;); ","permalink":"https://eoezora.github.io/posts/mysql-note/%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/","summary":"多表查询 连接查询 内连接 获取两表的交集数据\n-- 隐式写法 SELECT 字段列表 FROM 表1, 表2... WHERE 条件; -- 显示写法 SELECT 字段列表 FROM 表1 INNER JOIN 表2 ON 条件 外连接 左外连接: 相当于查询A表所有数据和交集部分的数据\n右外连接: 相当于查询B表所有数据和交集部分的数据\n-- 左外连接 SELECT 字段列表 FROM 表1 LEFT OUTER JOIN 表2 ON 条件 -- 右外连接 SELECT 字段列表 FROM 表1 RIGHT OUTER JOIN 表2 ON 条件 子查询 概念：查询中嵌套查询,根据查询结果不同，作用不同分为 单行单列，多行单列，多行多列\n-- 单行单列: 作为条件值 使用 = != \u0026gt; \u0026lt; 进行条件判断 SELECT 字段列表 FROM 表 WHERE 字段名 = (子查询语句); -- 多行单列: 作为条件值 SELECT 字段列表 FROM 表 WHERE 字段名 IN (子查询语句); -- 多行多列: 作为虚拟表 SELECT 字段列表 FROM (子查询语句) WHERE 条件; -- 例子 查询工资大于 蔡徐坤 的数据 SELECT name FROM users WHERE money \u0026gt; (SELECT money FROM infos WHERE name = \u0026#34;蔡徐坤\u0026#34;); ","title":"Mysql笔记-数据库设计-多表查询"},{"content":"表之间的关系 一对一 例如，用户表和用户信息表(不常用的信息)\n实现方式: 在任意一方加入外键，关联另一方主键，并且设置外键为唯一(UNIQUE)\n一对多(多对一) 例如：一个部门有多个员工，多个员工属于一个部门\n实现方式：在多的一方添加一个外键，指向一的主键,例如 在员工表里添加一个部门ID外键，指向部门表的主键\n多对多 例如：商品和订单，一个订单多个商品，一个商品多个订单\n实现方式：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键\n订单表\nid 支付金额 支付方式 状态 1 114514.0 WeChatPay 未支付 2 19198.0 AliPay 已支付 商品表\nid 商品名 价格 1 林檎 114514 2 迎宾酒 1919810 中间表\nid 订单id(外键) 商品id(外键) 1 1 1 2 1 2 3 2 1 注解：以上方三表为例，中间表记录订单与商品的外键。两个订单id为1的数据代表着这个订单有两件商品\n-- 订单与商品关联例子 create table if not exists orders ( id int auto_increment primary key, payment int not null, paytype varchar(20) not null, status varchar(20) not null ); create table if not exists goods ( id int auto_increment primary key, name varchar(60) not null, price int not null ); create table if not exists tk_orders_goods ( id int auto_increment primary key, order_id int not null, good_id int not null ); -- 添加外键 alter table tk_orders_goods add constraint fk_order_id FOREIGN KEY(order_id) REFERENCES orders(id); -- 添加外键 alter table tk_orders_goods add constraint fk_good_id FOREIGN KEY(good_id) REFERENCES goods(id); ","permalink":"https://eoezora.github.io/posts/mysql-note/%E8%A1%A8%E4%B9%8B%E9%97%B4%E5%85%B3%E7%B3%BB/","summary":"表之间的关系 一对一 例如，用户表和用户信息表(不常用的信息)\n实现方式: 在任意一方加入外键，关联另一方主键，并且设置外键为唯一(UNIQUE)\n一对多(多对一) 例如：一个部门有多个员工，多个员工属于一个部门\n实现方式：在多的一方添加一个外键，指向一的主键,例如 在员工表里添加一个部门ID外键，指向部门表的主键\n多对多 例如：商品和订单，一个订单多个商品，一个商品多个订单\n实现方式：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键\n订单表\nid 支付金额 支付方式 状态 1 114514.0 WeChatPay 未支付 2 19198.0 AliPay 已支付 商品表\nid 商品名 价格 1 林檎 114514 2 迎宾酒 1919810 中间表\nid 订单id(外键) 商品id(外键) 1 1 1 2 1 2 3 2 1 注解：以上方三表为例，中间表记录订单与商品的外键。两个订单id为1的数据代表着这个订单有两件商品\n-- 订单与商品关联例子 create table if not exists orders ( id int auto_increment primary key, payment int not null, paytype varchar(20) not null, status varchar(20) not null ); create table if not exists goods ( id int auto_increment primary key, name varchar(60) not null, price int not null ); create table if not exists tk_orders_goods ( id int auto_increment primary key, order_id int not null, good_id int not null ); -- 添加外键 alter table tk_orders_goods add constraint fk_order_id FOREIGN KEY(order_id) REFERENCES orders(id); -- 添加外键 alter table tk_orders_goods add constraint fk_good_id FOREIGN KEY(good_id) REFERENCES goods(id); ","title":"Mysql笔记-数据库设计-表之间的关系"},{"content":"事务概念 数据库的事务是一种机制，一个操作序列，包含一组数据库操作命令 事务把所有命令作为一个整体向系统提交或撤销。这组命令要么同时成功，要么同时失败 -- 定义事务开启 -- 事务开启后所作的操作为临时性的 BEGIN; -- 也可以使用 START TRANSACTION; UPDATE account SET money = money + 1000 WHERE name = \u0026#39;蔡徐坤\u0026#39;; 假设这行语句错误 UPDATE account SET money = money - 8000 WHERE name = \u0026#39;孙笑川\u0026#39;; -- 提交事务 COMMIT; -- 回滚操作 ROLLBACK; 事务四大特性 原子性：事务是不可分割的最小操作单位，要么同时成功，要么同时失败；\n一致性：事务完成后，必须是所有数据都保持一致状态\n隔离性：多个事务之间，操作的可见性。每个事务之间操作隔离\n持久性：事务一旦提交或者回滚，他对数据库的改变就是永久的\n-- 查看事务默认提交方式 SELECT @@autocommit; -- 修改默认提交方式 - 1 自动提交 - 0 手动提交 set @@autocommit = 0; ","permalink":"https://eoezora.github.io/posts/mysql-note/%E4%BA%8B%E5%8A%A1/","summary":"事务概念 数据库的事务是一种机制，一个操作序列，包含一组数据库操作命令 事务把所有命令作为一个整体向系统提交或撤销。这组命令要么同时成功，要么同时失败 -- 定义事务开启 -- 事务开启后所作的操作为临时性的 BEGIN; -- 也可以使用 START TRANSACTION; UPDATE account SET money = money + 1000 WHERE name = \u0026#39;蔡徐坤\u0026#39;; 假设这行语句错误 UPDATE account SET money = money - 8000 WHERE name = \u0026#39;孙笑川\u0026#39;; -- 提交事务 COMMIT; -- 回滚操作 ROLLBACK; 事务四大特性 原子性：事务是不可分割的最小操作单位，要么同时成功，要么同时失败；\n一致性：事务完成后，必须是所有数据都保持一致状态\n隔离性：多个事务之间，操作的可见性。每个事务之间操作隔离\n持久性：事务一旦提交或者回滚，他对数据库的改变就是永久的\n-- 查看事务默认提交方式 SELECT @@autocommit; -- 修改默认提交方式 - 1 自动提交 - 0 手动提交 set @@autocommit = 0; ","title":"Mysql笔记-事务"},{"content":"约束概念 约束是作用于表中列的规则，用于限制加入表的数据 约束的存在保证数据库数据的正确性，有限性和完整性 约束的分类 约束名称 功能描述 关键字 非空约束 保证列中数据不出现null NOT NULL 唯一约束 保证列中数据各不相同，唯一性 UNIQUE 主键约束 主键是一行数据的唯一标识，要求非空且唯一 PRIMARY KEY 默认约束 保存数据时,未指定就采用默认值 DEFAULT 外键约束 外键让两个表的数据之间建立连接，保证数据一致且完整 FOREIGN KEY 例子 -- 建表时对字段进行约束 CREATE TABLE emp( id INT PRIMARY KEY, -- 唯一主键 ename VARCHAR(60) NOT NULL UNIQUE, -- 非空且唯一 joindate DATE NOT NULL, -- 非空 salary DOUBLE(7,2) NOT NULL, -- 非空 bonus DOUBLE(7,2) DEFAULT 0, -- 默认为0 -- 部门id dept_id INT NOT NULL, -- 添加外键dept_id并关联dept表的id主键 CONSTRAINF fk_emp_dept FOREIGN KEY(dept_id) REFERENCES dept(id) ); 外键约束 员工表(emp)\nid name age dep_id 1 张三 22 1 2 李四 23 1 3 王五 24 2 4 赵六 25 2 部门表(dept)\nid dep_name addr 1 研发部 研发部地址 2 产品部 产品部地址 ","permalink":"https://eoezora.github.io/posts/mysql-note/%E7%BA%A6%E6%9D%9F/","summary":"约束概念 约束是作用于表中列的规则，用于限制加入表的数据 约束的存在保证数据库数据的正确性，有限性和完整性 约束的分类 约束名称 功能描述 关键字 非空约束 保证列中数据不出现null NOT NULL 唯一约束 保证列中数据各不相同，唯一性 UNIQUE 主键约束 主键是一行数据的唯一标识，要求非空且唯一 PRIMARY KEY 默认约束 保存数据时,未指定就采用默认值 DEFAULT 外键约束 外键让两个表的数据之间建立连接，保证数据一致且完整 FOREIGN KEY 例子 -- 建表时对字段进行约束 CREATE TABLE emp( id INT PRIMARY KEY, -- 唯一主键 ename VARCHAR(60) NOT NULL UNIQUE, -- 非空且唯一 joindate DATE NOT NULL, -- 非空 salary DOUBLE(7,2) NOT NULL, -- 非空 bonus DOUBLE(7,2) DEFAULT 0, -- 默认为0 -- 部门id dept_id INT NOT NULL, -- 添加外键dept_id并关联dept表的id主键 CONSTRAINF fk_emp_dept FOREIGN KEY(dept_id) REFERENCES dept(id) ); 外键约束 员工表(emp)","title":"Mysql笔记-约束"},{"content":"SELECT -- 字段列表 FROM -- 表名列表 WHERE -- 条件列表 GROUP BY -- 分组列表 HAVING -- 分组后条件 ORDER BY -- 排序字段 LIMIT -- 限制查询返回数据的数量，用于分页限制 条件查询 -- 查询表里许所有数据,不建议使用 SELECT * FROM users; -- 查询名字 -- DISTINCT 去除重复 SELECT DISTINCT name FROM users; -- 查询名字，性别，年龄 -- 可以使用 sex as 性别 的方式对列起别名,也可以写成 sex 性别 省略as 但字段名跟别名之间要有空格隔开 SELECT name, sex as 性别, age as 年龄 FROM users; -- 条件查询符号, NULL值比较使用 IS NOT NULL 跟 IS NULL SELECT name FROM users WHERE age \u0026gt; 17; -- 查询age数值大于17的数据 SELECT name FROM users WHERE age \u0026gt;= 7 AND age \u0026lt;= 50; -- 查询age数值在7跟50之间的数值(写法一) SELECT name FROM users WHERE age BETWEEN 7 AND 50; -- 查询age数值在7跟50之间的数值(写法二) -- 查询brith_day数值在\u0026#39;2000-01-01\u0026#39;跟\u0026#39;2000-04-01\u0026#39;之间的数值(写法二) SELECT name FROM users WHERE brith_day BETWEEN \u0026#39;2000-01-01\u0026#39; AND \u0026#39;2000-04-01\u0026#39;; SELECT name FROM users WHERE age = 17; -- 查询age数值等于17的数据 SELECT name FROM users WHERE age != 17; -- 查询age数值不等于17的数据(写法一) SELECT name FROM users WHERE age \u0026lt;\u0026gt; 17; -- 查询age数值不等于17的数据(写法二) SELECT name FROM users WHERE age = 17 OR age = 18 OR age = 22;-- 查询age数值等于17或18或22的数据(写法一) SELECT name FROM users WHERE age IN (17，18，22); -- 查询age数值等于17或18或22的数据(写法二) SELECT name FROM users WHERE age IS NULL; -- 查询age数值为null的数据 SELECT name FROM users WHERE age IS NOT NULL; -- 查询age数值不为null的数据 SELECT name FROM users WHERE age IS NULL -- 查询age数值为null的数据 /* 通配符 _ 下划线代表单个字符 % 百分号代表任意个数字符 */ -- 查询姓为 蔡 的名字信息 SELECT name FROM users WHERE name like \u0026#39;蔡%\u0026#39;; -- 查询名字 第二个字是 徐 的名字信息 SELECT name FROM users WHERE name like \u0026#39;_徐%\u0026#39;; -- 查询名字中包含坤的名字信息 SELECT name FROM users WHERE name like \u0026#39;%坤%\u0026#39;; 排序查询 -- 排序查询语法 SELECT 字段列表 FROM 表名 ORDER BY 排序字段名1 [排序方式1]，排序字段名2 [排序方式2]...; -- 排序方式 -- ASC 升序排列[默认] -- DESC 降序排列 -- 升序排序例子 SELECT name FROM users ORDER BY age ASC; -- 降序排序例子 SELECT name FROM users ORDER BY age DESC; -- 多字段降序排序例子 -- 如果年龄一样，则按工资升序排序 SELECT name FROM users ORDER BY age DESC, money ASC; 分组查询 -- 聚合函数查询 count(列名) -- 统计数量 max(列名) -- 最大值 min(列名) -- 最小值 sum(列名) -- 求和 avg(列名) -- 求平均值 -- 聚合函数查询语法 SELECT 聚合函数(列名)... FROM users; SELECT COUNT(name) FROM users; -- 统计name有几个，不能为空，不会统计null值 SELECT MAX(age) FROM users； -- 求年龄最大的 SELECT MIN(age) FROM users； -- 求年龄最小的 SELECT SUM(money) FROM users； -- 求一整列的 money 和 SELECT AVG(money) FROM users； -- 求一整列的 money 的平均值 -- 分组查询 -- 根据性别分组查询平均工资 SELECT sex, avg(money) FROM users GROUP BY sex; -- 根据性别分组查询平均工资，只计算工资高于5000的数据 SELECT sex, avg(money) FROM users WHERE money \u0026gt; 5000 GROUP BY sex; -- 根据性别分组查询平均工资，只计算工资高于5000的数据, 且数据大于2条 SELECT sex, avg(money) FROM users WHERE money \u0026gt; 5000 GROUP BY sex HAVING COUNT(*) \u0026gt; 2; 分页查询 -- 语法 SELECT name SELECT name FROM users LIMIT 起始索引，查询数目量; -- 从0开始查，查询3条数据 SELECT name FROM users LIMIT 0，3; -- 分页查询 SELECT name FROM users LIMIT (当前页面 -1) * 每页显示条目数，每页显示条目数; ","permalink":"https://eoezora.github.io/posts/mysql-note/%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2/","summary":"SELECT -- 字段列表 FROM -- 表名列表 WHERE -- 条件列表 GROUP BY -- 分组列表 HAVING -- 分组后条件 ORDER BY -- 排序字段 LIMIT -- 限制查询返回数据的数量，用于分页限制 条件查询 -- 查询表里许所有数据,不建议使用 SELECT * FROM users; -- 查询名字 -- DISTINCT 去除重复 SELECT DISTINCT name FROM users; -- 查询名字，性别，年龄 -- 可以使用 sex as 性别 的方式对列起别名,也可以写成 sex 性别 省略as 但字段名跟别名之间要有空格隔开 SELECT name, sex as 性别, age as 年龄 FROM users; -- 条件查询符号, NULL值比较使用 IS NOT NULL 跟 IS NULL SELECT name FROM users WHERE age \u0026gt; 17; -- 查询age数值大于17的数据 SELECT name FROM users WHERE age \u0026gt;= 7 AND age \u0026lt;= 50; -- 查询age数值在7跟50之间的数值(写法一) SELECT name FROM users WHERE age BETWEEN 7 AND 50; -- 查询age数值在7跟50之间的数值(写法二) -- 查询brith_day数值在\u0026#39;2000-01-01\u0026#39;跟\u0026#39;2000-04-01\u0026#39;之间的数值(写法二) SELECT name FROM users WHERE brith_day BETWEEN \u0026#39;2000-01-01\u0026#39; AND \u0026#39;2000-04-01\u0026#39;; SELECT name FROM users WHERE age = 17; -- 查询age数值等于17的数据 SELECT name FROM users WHERE age !","title":"Mysql笔记-单表查询"},{"content":"24岁是学生，正在自学编程中，本站记录学习过程中的一些笔记\n","permalink":"https://eoezora.github.io/about/","summary":"24岁是学生，正在自学编程中，本站记录学习过程中的一些笔记","title":"🙋🏻‍♂️关于"}]