[{"content":"请求的数据格式 数据分为三部分\n请求行: 请求数据第一行, GET/POST 表示请求方式 / 表示请求路径 HTTP/1.1表示协议版本 请求头: 键值对数据 请求体: POST请求的最后一部分, 存放请求参数 例子:\nGET / HTTP/1.1 浏览器能够接受的资源类型 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 浏览器可以支持的压缩类型 Accept-Encoding: gzip, deflate, br 浏览器偏好语言 Accept-Language: en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7 Cache-Control: max-age=0 Connection: keep-alive Cookie: 请求主机名 Host: www.baidu.com Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: none Sec-Fetch-User: ?1 Upgrade-Insecure-Requests: 1 浏览器版本 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36 sec-ch-ua: \u0026#34;Chromium\u0026#34;;v=\u0026#34;106\u0026#34;, \u0026#34;Google Chrome\u0026#34;;v=\u0026#34;106\u0026#34;, \u0026#34;Not;A=Brand\u0026#34;;v=\u0026#34;99\u0026#34; sec-ch-ua-mobile: ?0 sec-ch-ua-platform: \u0026#34;Windows\u0026#34; GET请求参数在请求行中.没有请求体\nPOST请求参数在请求体中\nGET请求有参数大小限制.POST没有\n响应的数据格式 数据分为三部分\n响应行: 响应数据第一行, HTTP/1.1表示协议版本 200 代表响应代码 OK 表示状态描述 响应头: 键值对数据 响应体: 最后一部分, 存放响应数据 HTTP/1.1 200 OK Bdpagetype: 2 Bdqid: 0xeaa6d46b0000e982 客户端如何缓存, 设置 max-age=300 表示最多缓存300秒 Cache-Control: private Connection: keep-alive 响应的压缩算法 Content-Encoding: gzip 响应内容的类型 Content-Type: text/html;charset=utf-8 响应内容长度(字节数) Content-Lenght: 100 Server: BWS/1.1 Set-Cookie: BDSVRTM=318; path=/ Set-Cookie: BD_HOME=1; path=/ Set-Cookie: H_PS_PSSID=37375_36551_37359_36884_37402_37396_37406_36786_37499_26350_37448_37370_37449; path=/; domain=.baidu.com Strict-Transport-Security: max-age=172800 Traceid: 1665032548061897473016908435407035754882 X-Frame-Options: sameorigin X-Ua-Compatible: IE=Edge,chrome=1 Transfer-Encoding: chunked ","permalink":"https://eoezora.github.io/posts/javaweb/javaweb-http/","summary":"请求的数据格式 数据分为三部分\n请求行: 请求数据第一行, GET/POST 表示请求方式 / 表示请求路径 HTTP/1.1表示协议版本 请求头: 键值对数据 请求体: POST请求的最后一部分, 存放请求参数 例子:\nGET / HTTP/1.1 浏览器能够接受的资源类型 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 浏览器可以支持的压缩类型 Accept-Encoding: gzip, deflate, br 浏览器偏好语言 Accept-Language: en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7 Cache-Control: max-age=0 Connection: keep-alive Cookie: 请求主机名 Host: www.baidu.com Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: none Sec-Fetch-User: ?1 Upgrade-Insecure-Requests: 1 浏览器版本 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36 sec-ch-ua: \u0026#34;Chromium\u0026#34;;v=\u0026#34;106\u0026#34;, \u0026#34;Google Chrome\u0026#34;;v=\u0026#34;106\u0026#34;, \u0026#34;Not;A=Brand\u0026#34;;v=\u0026#34;99\u0026#34; sec-ch-ua-mobile: ?0 sec-ch-ua-platform: \u0026#34;Windows\u0026#34; GET请求参数在请求行中.","title":"JavaWEB笔记-HTTP"},{"content":"快速入门 创建web项目,导入servlet坐标\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javax.servlet-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.0.1\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Tomcat 10 使用这个--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;jakarta.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jakarta.servlet-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.0.0\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; 简单使用例\npackage com.eoezora.controller; import jakarta.servlet.ServletException; import jakarta.servlet.annotation.WebServlet; import jakarta.servlet.http.HttpServlet; import jakarta.servlet.http.HttpServletRequest; import jakarta.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(\u0026#34;/test\u0026#34;) // 访问路径是 /test public class TestController extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\u0026#34;get\u0026#34;); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\u0026#34;post\u0026#34;); } } urlPattern配置 Servlet想要被访问,就必须设置其访问路径 (urlPattern)\n一个Servlet可以配置多个urlPattern, 例如 @WebServlet(urlPattern = {\u0026quot;/test1\u0026quot;, \u0026ldquo;/test2\u0026rdquo;, \u0026ldquo;/test3\u0026rdquo;})\nurlPattern配置规则\n优先级: 精确路径匹配 \u0026gt; 目录路径匹配 \u0026gt; 扩展名匹配 \u0026gt; / /*\n精确匹配 @WebServlet(\u0026#34;/user/info\u0026#34;) //访问路径为 -\u0026gt; http://localhost:8080/webapp/user/info 目录匹配 以下面例子来说,只要在/user目录下的请求都能访问该Servlet\n@WebServlet(\u0026#34;/user/*\u0026#34;) //访问路径为 -\u0026gt; http://localhost:8080/webapp/user/aaa | http://localhost:8080/webapp/user/bbb 拓展名匹配 访问该拓展名的文件资源\n@WebServlet(\u0026#34;*.do\u0026#34;) //访问路径为 -\u0026gt; http://localhost:8080/webapp/aaa.do 任意匹配 不管访问地址是啥，都能访问这个Servlet\n@WebServlet(\u0026#34;/\u0026#34;) @WebServlet(\u0026#34;/*\u0026#34;) //访问路径为 -\u0026gt; http://localhost:8080/webapp/abc 可以用任意路径访问这个Servlet //当我们在项目中设置了 \u0026#34;/\u0026#34; 和 \u0026#34;/*\u0026#34; 后会覆盖掉tomcat默认的DefaultServlet.当其他的urlPattern都匹配不上时会访问这个Servlet xml配置Servlet 需要在web.xml中配置, 例子如下, Servlet类与注解方式一样，只是不需要写注解@WebServlet\n\u0026lt;servlet\u0026gt; \u0026lt;!-- servlet名字 --\u0026gt; \u0026lt;servlet-name\u0026gt;test\u0026lt;/servlet-name\u0026gt; \u0026lt;!-- servlet类的路径 --\u0026gt; \u0026lt;servlet-class\u0026gt;com.eoezora.controller.TestController\u0026lt;/servlet-class\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;!-- servlet名字 --\u0026gt; \u0026lt;servlet-name\u0026gt;test\u0026lt;/servlet-name\u0026gt; \u0026lt;!-- servlet访问路径 --\u0026gt; \u0026lt;url-pattern\u0026gt;/test\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; ","permalink":"https://eoezora.github.io/posts/javaweb/javaweb-tomcat/","summary":"快速入门 创建web项目,导入servlet坐标\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javax.servlet-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.0.1\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Tomcat 10 使用这个--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;jakarta.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jakarta.servlet-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.0.0\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; 简单使用例\npackage com.eoezora.controller; import jakarta.servlet.ServletException; import jakarta.servlet.annotation.WebServlet; import jakarta.servlet.http.HttpServlet; import jakarta.servlet.http.HttpServletRequest; import jakarta.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(\u0026#34;/test\u0026#34;) // 访问路径是 /test public class TestController extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\u0026#34;get\u0026#34;); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\u0026#34;post\u0026#34;); } } urlPattern配置 Servlet想要被访问,就必须设置其访问路径 (urlPattern)","title":"JavaWEB笔记-Servlet"},{"content":"介绍 Request: 获取请求数据 Response: 设置响应数据 Request 获取请求数据 一些需要了解的方法\n@Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // http://localhost:8080/EoeWebDemo_war/test?username=aas\u0026amp;password=1234567 // 请求行的数据 req.getMethod(); // GET 提交方法 req.getContextPath(); // EoeWebDemo_war 虚拟路径 req.getRequestURL(); // http://localhost:8080/EoeWebDemo_war/test req.getRequestURI(); // /EoeWebDemo_war/test req.getQueryString(); // username=aas\u0026amp;password=1234567 //请求头的数据, 根据请求头名称获取值 req.getHeader(\u0026#34;User-Agent\u0026#34;); //Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36 } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //获取POST请求体的数据 //获取流对象 // BufferedReader getReader()：获取字符输入流 只能操作字符数据 // ServletInputStream getInputStream()：获取字节输入流 可以操作所有类型数据 req.getInputStream(); req.getReader(); } Reuqest提供的获取参数的方法,不管是get还是post都通用\n//获取所有参数 Map\u0026lt;String, String[]\u0026gt; stringMap = req.getParameterMap(); //获取指定参数名的多个值 String[] pars = req.getParameterValues(\u0026#34;某个参数名\u0026#34;); //获取指定参数的单个值 String par = req.getParameter(\u0026#34;某个参数名\u0026#34;); 中文参数乱码解决方式 浏览器对url中的中文会进行URL编码,而Tomcat在解码时使用的字符集是ISO-8859-1, 会导致中文乱码.\n//POST请求直接使用这个方法设置即可 req.setCharacterEncoding(\u0026#34;UTF-8\u0026#34;); //GET请求需要我们手动对字符串进行编码解码操作 //把收到的字符串转为二进制 byte[] bytes = req.getParameter(\u0026#34;参数名\u0026#34;).getBytes(); //在用utf8字符集把二进制数据转成String String newParame = new String(bytes, StandardCharsets.UTF_8); 请求转发 Response ","permalink":"https://eoezora.github.io/posts/javaweb/javaweb-%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94/","summary":"介绍 Request: 获取请求数据 Response: 设置响应数据 Request 获取请求数据 一些需要了解的方法\n@Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // http://localhost:8080/EoeWebDemo_war/test?username=aas\u0026amp;password=1234567 // 请求行的数据 req.getMethod(); // GET 提交方法 req.getContextPath(); // EoeWebDemo_war 虚拟路径 req.getRequestURL(); // http://localhost:8080/EoeWebDemo_war/test req.getRequestURI(); // /EoeWebDemo_war/test req.getQueryString(); // username=aas\u0026amp;password=1234567 //请求头的数据, 根据请求头名称获取值 req.getHeader(\u0026#34;User-Agent\u0026#34;); //Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36 } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //获取POST请求体的数据 //获取流对象 // BufferedReader getReader()：获取字符输入流 只能操作字符数据 // ServletInputStream getInputStream()：获取字节输入流 可以操作所有类型数据 req.","title":"JavaWEB笔记-请求和响应"},{"content":"增删改查例子 AccountMapper.xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;!-- namespace是映射接口的路径 --\u0026gt; \u0026lt;mapper namespace=\u0026#34;com.eoezora.mybatisDemo.mapper.AccountMapper\u0026#34;\u0026gt; \u0026lt;!-- 添加数据, 参数POJO -\u0026gt; EoeAccount --\u0026gt; \u0026lt;!-- 添加这两个 useGeneratedKeys=\u0026#34;true\u0026#34; keyProperty=\u0026#34;id\u0026#34; 属性在insert标签里可以返回主键 --\u0026gt; \u0026lt;insert id=\u0026#34;addAccount\u0026#34; useGeneratedKeys=\u0026#34;true\u0026#34; keyProperty=\u0026#34;id\u0026#34;/\u0026gt; \u0026lt;insert id=\u0026#34;addAccount\u0026#34; \u0026gt; INSERT INTO account (name, age, brithDay, location) \u0026lt;!-- 这里的名字要与POJO类力的变量名一致 --\u0026gt; VALUES (#{name},#{age},#{brithDay},#{location}); \u0026lt;/insert\u0026gt; \u0026lt;!-- 删除一条数据 --\u0026gt; \u0026lt;delete id=\u0026#34;delAccouintById\u0026#34;\u0026gt; DELETE FROM account WHERE id = #{id} \u0026lt;/delete\u0026gt; \u0026lt;!-- 删除多条数据 --\u0026gt; \u0026lt;delete id=\u0026#34;delAccouintByIds\u0026#34;\u0026gt; DELETE FROM account WHERE id in \u0026lt;!-- collection需要遍历的集合 item 集合里的元素 separator 分隔符 open 前缀符 close 后缀符 --\u0026gt; \u0026lt;foreach collection=\u0026#34;ids\u0026#34; item=\u0026#34;id\u0026#34; separator=\u0026#34;,\u0026#34; open=\u0026#34;(\u0026#34; close=\u0026#34;)\u0026#34;\u0026gt; #{id} \u0026lt;/foreach\u0026gt; \u0026lt;/delete\u0026gt; \u0026lt;!-- 查询所以数据 多个条件使用 and 分割 --\u0026gt; \u0026lt;select id=\u0026#34;selectAccounts\u0026#34; resultType=\u0026#34;com.eoezora.mybatisDemo.pojo.EoeAccount\u0026#34;\u0026gt; SELECT * FROM account; \u0026lt;/select\u0026gt; \u0026lt;!-- 根据ID查询数据 --\u0026gt; \u0026lt;select id=\u0026#34;selectAccount\u0026#34; parameterType=\u0026#34;int\u0026#34; resultType=\u0026#34;com.eoezora.mybatisDemo.pojo.EoeAccount\u0026#34;\u0026gt; SELECT * FROM account WHERE id = #{id}; \u0026lt;/select\u0026gt; \u0026lt;!-- 根据ID修改数据 --\u0026gt; \u0026lt;!-- 动态修改参考动态查询 --\u0026gt; \u0026lt;update id=\u0026#34;setAccountAge\u0026#34;\u0026gt; UPDATE account SET age = #{age} WHERE id = #{id} \u0026lt;/update\u0026gt; \u0026lt;/mapper\u0026gt; AccountMapper.class package com.eoezora.mybatisDemo.mapper; import com.eoezora.mybatisDemo.pojo.EoeAccount; import java.util.List; //映射接口, 方法名与上方SQL映射xml里的ID一致 public interface AccountMapper { /** * \u0026lt;insert id=\u0026#34;addAccount\u0026#34; parameterType=\u0026#34;com.eoezora.mybatisDemo.pojo.EoeAccount\u0026#34;\u0026gt; **/ void addAccount(EoeAccount eoeAccount); /** * \u0026lt;select id=\u0026#34;selectAccounts\u0026#34; resultType=\u0026#34;com.eoezora.mybatisDemo.pojo.EoeAccount\u0026#34;\u0026gt; **/ List\u0026lt;EoeAccount\u0026gt; selectAccounts(); /** * \u0026lt;select id=\u0026#34;selectAccount\u0026#34; parameterType=\u0026#34;int\u0026#34; resultType=\u0026#34;com.eoezora.mybatisDemo.pojo.EoeAccount\u0026#34;\u0026gt; **/ EoeAccount selectAccount(@Param(\u0026#34;id\u0026#34;)int id); /** * \u0026lt;delete id=\u0026#34;delAccouintById\u0026#34;\u0026gt; **/ void delAccouintById(@Param(\u0026#34;id\u0026#34;)int id); /** * \u0026lt;delete id=\u0026#34;delAccouintByIds\u0026#34;\u0026gt; 传入数组批量删除多条数据 **/ void delAccouintById(@Param(\u0026#34;ids\u0026#34;) int[] id); //传递参数的三种方式 /** * 多个单独的参数, @Param里的值与xml映射表的占位符一致,也就是与 xml 里的 #{} 里的一致 例如: #{name} **/ List\u0026lt;EoeAccount\u0026gt; selectAccountByCondition(@Param(\u0026#34;name\u0026#34;) String name, @Param(\u0026#34;age\u0026#34;) intn age); /** * 如果参数可以封装在同一个类里,也可以直接传一个对象过来. xml #{} 将使用该对象参数名作为占位符 **/ List\u0026lt;EoeAccount\u0026gt; selectAccountByCondition(EoeAccount account); /** * HashMap key -\u0026gt; value * - 占位符名称 -\u0026gt; 数值 **/ List\u0026lt;EoeAccount\u0026gt; selectAccountByCondition(Map map); /** * 使用注解查询, 一般使用在简单的sql语句上, 复杂的语句还是使用xml映射 **/ @Select(\u0026#34;SELECT * FROM account WHERE id = #{id}\u0026#34;) EoeAccount selectAccount(int id); } 使用接口进行增删改查 try (SqlSession session = sqlSessionFactory.openSession()) { AccountMapper mapper = session.getMapper(AccountMapper.class); mapper.selectAccounts(); mapper.addAccount(); //需要注意的是 mybatis 对数据库进行增删改的操作后需要手动提交 session.commit(); } /** * 获取主键 * 当数据添加完成后, 若insert标签有设置useGeneratedKeys=\u0026#34;true\u0026#34; keyProperty=\u0026#34;id\u0026#34; 属性 * 则可以根据 以下方式获取返回的主键id **/ EoeAccount ea = new EoeAccount(\u0026#34;蔡某\u0026#34;,25,\u0026#34;1919-08-10\u0026#34;,\u0026#34;荔枝星\u0026#34;); mapper.addAccount(ea); System.out.println(ea.getId()); 多条件动态查询 在根据条件查询时,多个条件使用以下方式,传入的条件参数是固定的。比如下面这条是3个.\n\u0026lt;!-- 查询所以数据 多个条件使用 and 分割 --\u0026gt; \u0026lt;select id=\u0026#34;selectAccounts\u0026#34; resultType=\u0026#34;com.eoezora.mybatisDemo.pojo.EoeAccount\u0026#34;\u0026gt; SELECT * FROM account WHERE id = 1 AND name = \u0026#39;xxx\u0026#39; AND AGE = 24; \u0026lt;/select\u0026gt; 有时候我们需要的是模糊查询, 用户给的条件数量是不固定的，有时一个有时三个。我们需要根据传来的条件参数数量来动态调整我们的SQL语句。MyBatis提供了许多标签来支持此功能: if | choose(when, otherwise) | trim(where, set) | foreach\n\u0026lt;select id=\u0026#34;selectAccounts\u0026#34; resultType=\u0026#34;com.eoezora.mybatisDemo.pojo.EoeAccount\u0026#34;\u0026gt; SELECT * FROM account \u0026lt;!-- 使用where标签可以解决第一个条件不存在时的报错, 同时会帮我们去掉多余的AND --\u0026gt; \u0026lt;!-- 下面为例 当id小于0，条件不会被拼到sql语句里,且会帮我们去掉name前面的AND --\u0026gt; \u0026lt;where\u0026gt; \u0026lt;!-- test后面跟判断条件 --\u0026gt; \u0026lt;if test=\u0026#34;id \u0026gt; 0\u0026#34;\u0026gt; AND id = #{id} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;name != null\u0026#34;\u0026gt; AND name LIKE #{name} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;age \u0026gt; 0\u0026#34;\u0026gt; AND age = #{age} \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; 单条件动态查询 当我们需要单条件动态查询时，使用以下方法\n\u0026lt;select id=\u0026#34;selectAccounts\u0026#34; resultType=\u0026#34;com.eoezora.mybatisDemo.pojo.EoeAccount\u0026#34;\u0026gt; SELECT * FROM account \u0026lt;where\u0026gt; \u0026lt;choose\u0026gt;\u0026lt;!-- 类似switch --\u0026gt; \u0026lt;when test=\u0026#34;id \u0026gt; 0\u0026#34;\u0026gt;\u0026lt;!-- 类似case --\u0026gt; id = #{id} \u0026lt;/when\u0026gt; \u0026lt;when test=\u0026#34;name != null and name != \u0026#39;\u0026#39;\u0026#34;\u0026gt; name like #{name} \u0026lt;/when\u0026gt; \u0026lt;when test=\u0026#34;age \u0026gt; 0\u0026#34;\u0026gt; age = #{age} \u0026lt;/when\u0026gt; \u0026lt;otherwise\u0026gt;1 = 1\u0026lt;/otherwise\u0026gt;\u0026lt;!-- 类似default 使用where标签可以去掉这个 --\u0026gt; \u0026lt;/choose\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; 参数传递 Mybatis接口方法可以接受各种各样的参数，底层会对这些参数进行不同的封装处理\n单个参数: POJO类型\nMap集合\nCoolection\nList\nArray\n其他类型\n多个参数: 类似EoeAccount selectAccount(@Param(\u0026ldquo;id\u0026rdquo;)int id, @Param(\u0026ldquo;name\u0026rdquo;)String name\u0026hellip;); 参数需要有@Param注解,里面的值与xml映射文件里的占位符一致\n#:D 参数占位符 #{}: 执行SQL时, 会将#{}占位符替换成 ? 会自动设置参数, 防止sql注入\n${}: 拼SQL语句,会出现sql注入问题.\n一般在传参数时使用 #{} 在对表名，列名进行动态设置时，使用${} 进行拼接.\nparameterType 用于设置传入的参数类型, 此属性可以省略\nresultType 执行SQL语句后返回的数据进行封装，此属性指定封装后的类型\nxml中特殊字符处理 在xml文件写SQL语句时难免会出现 大于小于的判断 而 \u0026lt; 是xml标签起始。所以需要进行处理。下面为例子\n\u0026lt;select id=\u0026#34;selectAccount\u0026#34; parameterType=\u0026#34;int\u0026#34; resultType=\u0026#34;com.eoezora.mybatisDemo.pojo.EoeAccount\u0026#34;\u0026gt; SELECT * FROM account \u0026lt;!-- 此处的小于号 \u0026lt; 会报错, 因为被xml判定成了不完成的标签 --\u0026gt; WHERE id \u0026lt; 5; \u0026lt;/select\u0026gt; \u0026lt;!-- 正确的写法应该是 CDATA 或者 转义字符 --\u0026gt; \u0026lt;select id=\u0026#34;selectAccount\u0026#34; parameterType=\u0026#34;int\u0026#34; resultType=\u0026#34;com.eoezora.mybatisDemo.pojo.EoeAccount\u0026#34;\u0026gt; SELECT * FROM account WHERE id \u0026lt;!-- 把他也输符号写在CDATA 里就不会报错了 --\u0026gt; \u0026lt;![CDATA[ \u0026lt; ]]\u0026gt; #{id}; \u0026lt;/select\u0026gt; ","permalink":"https://eoezora.github.io/posts/mybatis/mybatis-%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/","summary":"增删改查例子 AccountMapper.xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;!-- namespace是映射接口的路径 --\u0026gt; \u0026lt;mapper namespace=\u0026#34;com.eoezora.mybatisDemo.mapper.AccountMapper\u0026#34;\u0026gt; \u0026lt;!-- 添加数据, 参数POJO -\u0026gt; EoeAccount --\u0026gt; \u0026lt;!-- 添加这两个 useGeneratedKeys=\u0026#34;true\u0026#34; keyProperty=\u0026#34;id\u0026#34; 属性在insert标签里可以返回主键 --\u0026gt; \u0026lt;insert id=\u0026#34;addAccount\u0026#34; useGeneratedKeys=\u0026#34;true\u0026#34; keyProperty=\u0026#34;id\u0026#34;/\u0026gt; \u0026lt;insert id=\u0026#34;addAccount\u0026#34; \u0026gt; INSERT INTO account (name, age, brithDay, location) \u0026lt;!-- 这里的名字要与POJO类力的变量名一致 --\u0026gt; VALUES (#{name},#{age},#{brithDay},#{location}); \u0026lt;/insert\u0026gt; \u0026lt;!-- 删除一条数据 --\u0026gt; \u0026lt;delete id=\u0026#34;delAccouintById\u0026#34;\u0026gt; DELETE FROM account WHERE id = #{id} \u0026lt;/delete\u0026gt; \u0026lt;!-- 删除多条数据 --\u0026gt; \u0026lt;delete id=\u0026#34;delAccouintByIds\u0026#34;\u0026gt; DELETE FROM account WHERE id in \u0026lt;!","title":"JavaWEB笔记-MyBatis-增删改查"},{"content":"简介: 一个用于数据持久层的框架\n基本配置 //mybatis配置文件 String resource = \u0026#34;mybatis-config.xml\u0026#34;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); try (SqlSession session = sqlSessionFactory.openSession()) { //此处是直接调用方法进行操作，建议使用代理开发 List\u0026lt;EoeAccount\u0026gt; datas = session.selectList(\u0026#34;test.selectAll\u0026#34;); datas.forEach(System.out::println); session.close(); } Mybatis配置文件(mybatis-config.xml)\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;https://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;environment id=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;/\u0026gt; \u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/eoezora?useSSL=false\u0026amp;amp;allowPublicKeyRetrieval=true\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper resource=\u0026#34;mappers/TestDemoMapper.xml\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;/configuration\u0026gt; SQL语句映射文件(TestDemoMapper.xml)\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;!-- 代理开发中 namespace的值应该是 Mapper接口的全限定名 --\u0026gt; \u0026lt;!-- 例如 com.eoezora.mapper.TestDemoMapper --\u0026gt; \u0026lt;mapper namespace=\u0026#34;test\u0026#34;\u0026gt; \u0026lt;!-- resultType 返回值 --\u0026gt; \u0026lt;select id=\u0026#34;selectAll\u0026#34; resultType=\u0026#34;com.eoezora.pojo.EoeAccount\u0026#34;\u0026gt; SELECT * FROM account; \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; Mapper代理开发 定义与SQL映射文件同名的Mapper接口,并且将Mapper接口与SQL映射文件放置在同名文件下\n设置SQL映射文件的namespace属性与Mapper接口全限定名\n在Mapper接口中定义方法,方法名是SQL映射文件中的sql语句ID，并保持参数类型和返回值类型一致\ntry (SqlSession session = sqlSessionFactory.openSession()) { //获取Mapper接口 TestDemoMapper testDemoMapper = session.getMapper(TestDemoMapper.class); //使用接口调用方法 testDemoMapper.selectAll().forEach(System.out::println); } ","permalink":"https://eoezora.github.io/posts/mybatis/mybatis/","summary":"简介: 一个用于数据持久层的框架\n基本配置 //mybatis配置文件 String resource = \u0026#34;mybatis-config.xml\u0026#34;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); try (SqlSession session = sqlSessionFactory.openSession()) { //此处是直接调用方法进行操作，建议使用代理开发 List\u0026lt;EoeAccount\u0026gt; datas = session.selectList(\u0026#34;test.selectAll\u0026#34;); datas.forEach(System.out::println); session.close(); } Mybatis配置文件(mybatis-config.xml)\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;https://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;environment id=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;/\u0026gt; \u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/eoezora?useSSL=false\u0026amp;amp;allowPublicKeyRetrieval=true\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper resource=\u0026#34;mappers/TestDemoMapper.xml\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;/configuration\u0026gt; SQL语句映射文件(TestDemoMapper.","title":"JavaWEB笔记-MyBatis快速入门笔记"},{"content":"简介\n","permalink":"https://eoezora.github.io/posts/mybatis/mybatis-%E9%85%8D%E7%BD%AE/","summary":"简介","title":"JavaWEB笔记-MyBatis配置文件"},{"content":"DriverManager //创建一个链接 String url = \u0026#34;jdbc:mysql://localhost/database?useSSL=false\u0026amp;allowPublicKeyRetrieval=true\u0026#34;; String user = \u0026#34;\u0026#34;; String pwd = \u0026#34;\u0026#34;; Connection connection = DriverManager.getConnection(url,user,pwd); Connection 用于获取执行SQL的对象和管理事务\n//创建链接 Connection connection = DriverManager.getConnection(url,user,pwd); //要执行的SQL语句 String sql = \u0026#34;UPDATE users SET money = 1000 WHERE id = 114514;\u0026#34;; //创建执行对象 Statement statement = connection.createStatement(); try { //开启事务 connection.setAutoCommit(false); //执行语句 statement.executeUpdate(sql); //事务提交 connection.commit(); } catch (Exception e) { //若执行失败则回滚事务 connection.rollback(); throw new RuntimeException(e); } Statement 作用：执行SQL语句\n//执行DML DDL 语句， 增删改，返回受影响的行数 int executeUpdate(String sql) //执行DQL语句 返回ResultSet结果集对象,查询语句 ResultSet executeQuery(String sql) ResultSet 作用：一个结果集对象，封装了DQL查询语句的结果\n//执行DQL语句返回ResultSet对象 ResultSet rs = statement.executeQuery(sql); //将光标从当前位置往前移动一行，判断当前是否为有效行 boolean next(); //true 有效行，当前行有数据 | 无效行 当前行无数据 //获取数据 //数据类型 get数据类型(参数); String getString(int index); //获取字段名 name 的值 ResultSet rs = statement.executeQuery(sql); while (rs.next()) { System.out.println(rs.getString(\u0026#34;name\u0026#34;)); } PreparedStatement 作用：预编译SQL语句并执行，预防SQL注入问题\nSQL注入是通过操作输入来修改事先定义号的SQL语句，用以达到攻击服务器的作用\nConnection connection = DriverManager.getConnection(url,user,pwd); String sql = \u0026#34;SELECT * FROM goods WHERE id = ?\u0026#34;; //获取预编译Sql对象 PreparedStatement ps = connection.prepareStatement(sql); //设置 ？的参数值 //参数位置 | 参数值 ps.setInt(1,1); //执行语句 ResultSet rs = ps.executeQuery(); rs.next(); System.out.println(rs.getString(\u0026#34;name\u0026#34;)); ","permalink":"https://eoezora.github.io/posts/jdbc-note/api%E8%AF%A6%E8%A7%A3/","summary":"DriverManager //创建一个链接 String url = \u0026#34;jdbc:mysql://localhost/database?useSSL=false\u0026amp;allowPublicKeyRetrieval=true\u0026#34;; String user = \u0026#34;\u0026#34;; String pwd = \u0026#34;\u0026#34;; Connection connection = DriverManager.getConnection(url,user,pwd); Connection 用于获取执行SQL的对象和管理事务\n//创建链接 Connection connection = DriverManager.getConnection(url,user,pwd); //要执行的SQL语句 String sql = \u0026#34;UPDATE users SET money = 1000 WHERE id = 114514;\u0026#34;; //创建执行对象 Statement statement = connection.createStatement(); try { //开启事务 connection.setAutoCommit(false); //执行语句 statement.executeUpdate(sql); //事务提交 connection.commit(); } catch (Exception e) { //若执行失败则回滚事务 connection.rollback(); throw new RuntimeException(e); } Statement 作用：执行SQL语句\n//执行DML DDL 语句， 增删改，返回受影响的行数 int executeUpdate(String sql) //执行DQL语句 返回ResultSet结果集对象,查询语句 ResultSet executeQuery(String sql) ResultSet 作用：一个结果集对象，封装了DQL查询语句的结果","title":"JavaWEB笔记-JDBC-API详解"},{"content":"简介: 数据库连接池是个容器, 负责分配, 管理数据库链接, 允许应用程序重复使用现有的数据库链接, 而不是重新建立一个新连接\n标准接口: DataSource\nDruid配置文件 url=jdbc:mysql:///eoezora?useSSL=false\u0026amp;allowPublicKeyRetrieval=true username=root password=root #初始化连接数量 initialSize=5 #最大连接数 maxActive=10 #最大等待时间 ms maxWait=3000 加载配置 //1.加载配置文件 Properties pro = new Properties(); InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream(\u0026#34;druid.properties\u0026#34;); pro.load(is); //2.获取连接池对象 DataSource ds = DruidDataSourceFactory.createDataSource(pro); //3.获取连接 Connection conn = ds.getConnection(); 归还连接|释放资源 public static void close(ResultSet rs, Statement stmt, Connection conn){ if (rs!=null) { try { rs.close(); } catch (Exception e) { System.out.println(e.getMessage()); } } if (stmt!=null) { try { stmt.close(); } catch (Exception e) { System.out.println(e.getMessage()); } } if (conn!=null){ try { conn.close();//归还连接 } catch (Exception e) { System.out.println(e.getMessage()); } } } ","permalink":"https://eoezora.github.io/posts/jdbc-note/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/","summary":"简介: 数据库连接池是个容器, 负责分配, 管理数据库链接, 允许应用程序重复使用现有的数据库链接, 而不是重新建立一个新连接\n标准接口: DataSource\nDruid配置文件 url=jdbc:mysql:///eoezora?useSSL=false\u0026amp;allowPublicKeyRetrieval=true username=root password=root #初始化连接数量 initialSize=5 #最大连接数 maxActive=10 #最大等待时间 ms maxWait=3000 加载配置 //1.加载配置文件 Properties pro = new Properties(); InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream(\u0026#34;druid.properties\u0026#34;); pro.load(is); //2.获取连接池对象 DataSource ds = DruidDataSourceFactory.createDataSource(pro); //3.获取连接 Connection conn = ds.getConnection(); 归还连接|释放资源 public static void close(ResultSet rs, Statement stmt, Connection conn){ if (rs!=null) { try { rs.close(); } catch (Exception e) { System.out.println(e.getMessage()); } } if (stmt!=null) { try { stmt.","title":"JavaWEB笔记-JDBC-连接池"},{"content":"多表查询 连接查询 内连接 获取两表的交集数据\n-- 隐式写法 SELECT 字段列表 FROM 表1, 表2... WHERE 条件; -- 显示写法 SELECT 字段列表 FROM 表1 INNER JOIN 表2 ON 条件 外连接 左外连接: 相当于查询A表所有数据和交集部分的数据\n右外连接: 相当于查询B表所有数据和交集部分的数据\n-- 左外连接 SELECT 字段列表 FROM 表1 LEFT OUTER JOIN 表2 ON 条件 -- 右外连接 SELECT 字段列表 FROM 表1 RIGHT OUTER JOIN 表2 ON 条件 子查询 概念：查询中嵌套查询,根据查询结果不同，作用不同分为 单行单列，多行单列，多行多列\n-- 单行单列: 作为条件值 使用 = != \u0026gt; \u0026lt; 进行条件判断 SELECT 字段列表 FROM 表 WHERE 字段名 = (子查询语句); -- 多行单列: 作为条件值 SELECT 字段列表 FROM 表 WHERE 字段名 IN (子查询语句); -- 多行多列: 作为虚拟表 SELECT 字段列表 FROM (子查询语句) WHERE 条件; -- 例子 查询工资大于 蔡徐坤 的数据 SELECT name FROM users WHERE money \u0026gt; (SELECT money FROM infos WHERE name = \u0026#34;蔡徐坤\u0026#34;); ","permalink":"https://eoezora.github.io/posts/mysql-note/%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/","summary":"多表查询 连接查询 内连接 获取两表的交集数据\n-- 隐式写法 SELECT 字段列表 FROM 表1, 表2... WHERE 条件; -- 显示写法 SELECT 字段列表 FROM 表1 INNER JOIN 表2 ON 条件 外连接 左外连接: 相当于查询A表所有数据和交集部分的数据\n右外连接: 相当于查询B表所有数据和交集部分的数据\n-- 左外连接 SELECT 字段列表 FROM 表1 LEFT OUTER JOIN 表2 ON 条件 -- 右外连接 SELECT 字段列表 FROM 表1 RIGHT OUTER JOIN 表2 ON 条件 子查询 概念：查询中嵌套查询,根据查询结果不同，作用不同分为 单行单列，多行单列，多行多列\n-- 单行单列: 作为条件值 使用 = != \u0026gt; \u0026lt; 进行条件判断 SELECT 字段列表 FROM 表 WHERE 字段名 = (子查询语句); -- 多行单列: 作为条件值 SELECT 字段列表 FROM 表 WHERE 字段名 IN (子查询语句); -- 多行多列: 作为虚拟表 SELECT 字段列表 FROM (子查询语句) WHERE 条件; -- 例子 查询工资大于 蔡徐坤 的数据 SELECT name FROM users WHERE money \u0026gt; (SELECT money FROM infos WHERE name = \u0026#34;蔡徐坤\u0026#34;); ","title":"Mysql笔记-数据库设计-多表查询"},{"content":"表之间的关系 一对一 例如，用户表和用户信息表(不常用的信息)\n实现方式: 在任意一方加入外键，关联另一方主键，并且设置外键为唯一(UNIQUE)\n一对多(多对一) 例如：一个部门有多个员工，多个员工属于一个部门\n实现方式：在多的一方添加一个外键，指向一的主键,例如 在员工表里添加一个部门ID外键，指向部门表的主键\n多对多 例如：商品和订单，一个订单多个商品，一个商品多个订单\n实现方式：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键\n订单表\nid 支付金额 支付方式 状态 1 114514.0 WeChatPay 未支付 2 19198.0 AliPay 已支付 商品表\nid 商品名 价格 1 林檎 114514 2 迎宾酒 1919810 中间表\nid 订单id(外键) 商品id(外键) 1 1 1 2 1 2 3 2 1 注解：以上方三表为例，中间表记录订单与商品的外键。两个订单id为1的数据代表着这个订单有两件商品\n-- 订单与商品关联例子 create table if not exists orders ( id int auto_increment primary key, payment int not null, paytype varchar(20) not null, status varchar(20) not null ); create table if not exists goods ( id int auto_increment primary key, name varchar(60) not null, price int not null ); create table if not exists tk_orders_goods ( id int auto_increment primary key, order_id int not null, good_id int not null ); -- 添加外键 alter table tk_orders_goods add constraint fk_order_id FOREIGN KEY(order_id) REFERENCES orders(id); -- 添加外键 alter table tk_orders_goods add constraint fk_good_id FOREIGN KEY(good_id) REFERENCES goods(id); ","permalink":"https://eoezora.github.io/posts/mysql-note/%E8%A1%A8%E4%B9%8B%E9%97%B4%E5%85%B3%E7%B3%BB/","summary":"表之间的关系 一对一 例如，用户表和用户信息表(不常用的信息)\n实现方式: 在任意一方加入外键，关联另一方主键，并且设置外键为唯一(UNIQUE)\n一对多(多对一) 例如：一个部门有多个员工，多个员工属于一个部门\n实现方式：在多的一方添加一个外键，指向一的主键,例如 在员工表里添加一个部门ID外键，指向部门表的主键\n多对多 例如：商品和订单，一个订单多个商品，一个商品多个订单\n实现方式：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键\n订单表\nid 支付金额 支付方式 状态 1 114514.0 WeChatPay 未支付 2 19198.0 AliPay 已支付 商品表\nid 商品名 价格 1 林檎 114514 2 迎宾酒 1919810 中间表\nid 订单id(外键) 商品id(外键) 1 1 1 2 1 2 3 2 1 注解：以上方三表为例，中间表记录订单与商品的外键。两个订单id为1的数据代表着这个订单有两件商品\n-- 订单与商品关联例子 create table if not exists orders ( id int auto_increment primary key, payment int not null, paytype varchar(20) not null, status varchar(20) not null ); create table if not exists goods ( id int auto_increment primary key, name varchar(60) not null, price int not null ); create table if not exists tk_orders_goods ( id int auto_increment primary key, order_id int not null, good_id int not null ); -- 添加外键 alter table tk_orders_goods add constraint fk_order_id FOREIGN KEY(order_id) REFERENCES orders(id); -- 添加外键 alter table tk_orders_goods add constraint fk_good_id FOREIGN KEY(good_id) REFERENCES goods(id); ","title":"Mysql笔记-数据库设计-表之间的关系"},{"content":"事务概念 数据库的事务是一种机制，一个操作序列，包含一组数据库操作命令 事务把所有命令作为一个整体向系统提交或撤销。这组命令要么同时成功，要么同时失败 -- 定义事务开启 -- 事务开启后所作的操作为临时性的 BEGIN; -- 也可以使用 START TRANSACTION; UPDATE account SET money = money + 1000 WHERE name = \u0026#39;蔡徐坤\u0026#39;; 假设这行语句错误 UPDATE account SET money = money - 8000 WHERE name = \u0026#39;孙笑川\u0026#39;; -- 提交事务 COMMIT; -- 回滚操作 ROLLBACK; 事务四大特性 原子性：事务是不可分割的最小操作单位，要么同时成功，要么同时失败；\n一致性：事务完成后，必须是所有数据都保持一致状态\n隔离性：多个事务之间，操作的可见性。每个事务之间操作隔离\n持久性：事务一旦提交或者回滚，他对数据库的改变就是永久的\n-- 查看事务默认提交方式 SELECT @@autocommit; -- 修改默认提交方式 - 1 自动提交 - 0 手动提交 set @@autocommit = 0; ","permalink":"https://eoezora.github.io/posts/mysql-note/%E4%BA%8B%E5%8A%A1/","summary":"事务概念 数据库的事务是一种机制，一个操作序列，包含一组数据库操作命令 事务把所有命令作为一个整体向系统提交或撤销。这组命令要么同时成功，要么同时失败 -- 定义事务开启 -- 事务开启后所作的操作为临时性的 BEGIN; -- 也可以使用 START TRANSACTION; UPDATE account SET money = money + 1000 WHERE name = \u0026#39;蔡徐坤\u0026#39;; 假设这行语句错误 UPDATE account SET money = money - 8000 WHERE name = \u0026#39;孙笑川\u0026#39;; -- 提交事务 COMMIT; -- 回滚操作 ROLLBACK; 事务四大特性 原子性：事务是不可分割的最小操作单位，要么同时成功，要么同时失败；\n一致性：事务完成后，必须是所有数据都保持一致状态\n隔离性：多个事务之间，操作的可见性。每个事务之间操作隔离\n持久性：事务一旦提交或者回滚，他对数据库的改变就是永久的\n-- 查看事务默认提交方式 SELECT @@autocommit; -- 修改默认提交方式 - 1 自动提交 - 0 手动提交 set @@autocommit = 0; ","title":"Mysql笔记-事务"},{"content":"约束概念 约束是作用于表中列的规则，用于限制加入表的数据 约束的存在保证数据库数据的正确性，有限性和完整性 约束的分类 约束名称 功能描述 关键字 非空约束 保证列中数据不出现null NOT NULL 唯一约束 保证列中数据各不相同，唯一性 UNIQUE 主键约束 主键是一行数据的唯一标识，要求非空且唯一 PRIMARY KEY 默认约束 保存数据时,未指定就采用默认值 DEFAULT 外键约束 外键让两个表的数据之间建立连接，保证数据一致且完整 FOREIGN KEY 例子 -- 建表时对字段进行约束 CREATE TABLE emp( id INT PRIMARY KEY, -- 唯一主键 ename VARCHAR(60) NOT NULL UNIQUE, -- 非空且唯一 joindate DATE NOT NULL, -- 非空 salary DOUBLE(7,2) NOT NULL, -- 非空 bonus DOUBLE(7,2) DEFAULT 0, -- 默认为0 -- 部门id dept_id INT NOT NULL, -- 添加外键dept_id并关联dept表的id主键 CONSTRAINF fk_emp_dept FOREIGN KEY(dept_id) REFERENCES dept(id) ); 外键约束 员工表(emp)\nid name age dep_id 1 张三 22 1 2 李四 23 1 3 王五 24 2 4 赵六 25 2 部门表(dept)\nid dep_name addr 1 研发部 研发部地址 2 产品部 产品部地址 ","permalink":"https://eoezora.github.io/posts/mysql-note/%E7%BA%A6%E6%9D%9F/","summary":"约束概念 约束是作用于表中列的规则，用于限制加入表的数据 约束的存在保证数据库数据的正确性，有限性和完整性 约束的分类 约束名称 功能描述 关键字 非空约束 保证列中数据不出现null NOT NULL 唯一约束 保证列中数据各不相同，唯一性 UNIQUE 主键约束 主键是一行数据的唯一标识，要求非空且唯一 PRIMARY KEY 默认约束 保存数据时,未指定就采用默认值 DEFAULT 外键约束 外键让两个表的数据之间建立连接，保证数据一致且完整 FOREIGN KEY 例子 -- 建表时对字段进行约束 CREATE TABLE emp( id INT PRIMARY KEY, -- 唯一主键 ename VARCHAR(60) NOT NULL UNIQUE, -- 非空且唯一 joindate DATE NOT NULL, -- 非空 salary DOUBLE(7,2) NOT NULL, -- 非空 bonus DOUBLE(7,2) DEFAULT 0, -- 默认为0 -- 部门id dept_id INT NOT NULL, -- 添加外键dept_id并关联dept表的id主键 CONSTRAINF fk_emp_dept FOREIGN KEY(dept_id) REFERENCES dept(id) ); 外键约束 员工表(emp)","title":"Mysql笔记-约束"},{"content":"SELECT -- 字段列表 FROM -- 表名列表 WHERE -- 条件列表 GROUP BY -- 分组列表 HAVING -- 分组后条件 ORDER BY -- 排序字段 LIMIT -- 限制查询返回数据的数量，用于分页限制 条件查询 -- 查询表里许所有数据,不建议使用 SELECT * FROM users; -- 查询名字 -- DISTINCT 去除重复 SELECT DISTINCT name FROM users; -- 查询名字，性别，年龄 -- 可以使用 sex as 性别 的方式对列起别名,也可以写成 sex 性别 省略as 但字段名跟别名之间要有空格隔开 SELECT name, sex as 性别, age as 年龄 FROM users; -- 条件查询符号, NULL值比较使用 IS NOT NULL 跟 IS NULL SELECT name FROM users WHERE age \u0026gt; 17; -- 查询age数值大于17的数据 SELECT name FROM users WHERE age \u0026gt;= 7 AND age \u0026lt;= 50; -- 查询age数值在7跟50之间的数值(写法一) SELECT name FROM users WHERE age BETWEEN 7 AND 50; -- 查询age数值在7跟50之间的数值(写法二) -- 查询brith_day数值在\u0026#39;2000-01-01\u0026#39;跟\u0026#39;2000-04-01\u0026#39;之间的数值(写法二) SELECT name FROM users WHERE brith_day BETWEEN \u0026#39;2000-01-01\u0026#39; AND \u0026#39;2000-04-01\u0026#39;; SELECT name FROM users WHERE age = 17; -- 查询age数值等于17的数据 SELECT name FROM users WHERE age != 17; -- 查询age数值不等于17的数据(写法一) SELECT name FROM users WHERE age \u0026lt;\u0026gt; 17; -- 查询age数值不等于17的数据(写法二) SELECT name FROM users WHERE age = 17 OR age = 18 OR age = 22;-- 查询age数值等于17或18或22的数据(写法一) SELECT name FROM users WHERE age IN (17，18，22); -- 查询age数值等于17或18或22的数据(写法二) SELECT name FROM users WHERE age IS NULL; -- 查询age数值为null的数据 SELECT name FROM users WHERE age IS NOT NULL; -- 查询age数值不为null的数据 SELECT name FROM users WHERE age IS NULL -- 查询age数值为null的数据 /* 通配符 _ 下划线代表单个字符 % 百分号代表任意个数字符 */ -- 查询姓为 蔡 的名字信息 SELECT name FROM users WHERE name like \u0026#39;蔡%\u0026#39;; -- 查询名字 第二个字是 徐 的名字信息 SELECT name FROM users WHERE name like \u0026#39;_徐%\u0026#39;; -- 查询名字中包含坤的名字信息 SELECT name FROM users WHERE name like \u0026#39;%坤%\u0026#39;; 排序查询 -- 排序查询语法 SELECT 字段列表 FROM 表名 ORDER BY 排序字段名1 [排序方式1]，排序字段名2 [排序方式2]...; -- 排序方式 -- ASC 升序排列[默认] -- DESC 降序排列 -- 升序排序例子 SELECT name FROM users ORDER BY age ASC; -- 降序排序例子 SELECT name FROM users ORDER BY age DESC; -- 多字段降序排序例子 -- 如果年龄一样，则按工资升序排序 SELECT name FROM users ORDER BY age DESC, money ASC; 分组查询 -- 聚合函数查询 count(列名) -- 统计数量 max(列名) -- 最大值 min(列名) -- 最小值 sum(列名) -- 求和 avg(列名) -- 求平均值 -- 聚合函数查询语法 SELECT 聚合函数(列名)... FROM users; SELECT COUNT(name) FROM users; -- 统计name有几个，不能为空，不会统计null值 SELECT MAX(age) FROM users； -- 求年龄最大的 SELECT MIN(age) FROM users； -- 求年龄最小的 SELECT SUM(money) FROM users； -- 求一整列的 money 和 SELECT AVG(money) FROM users； -- 求一整列的 money 的平均值 -- 分组查询 -- 根据性别分组查询平均工资 SELECT sex, avg(money) FROM users GROUP BY sex; -- 根据性别分组查询平均工资，只计算工资高于5000的数据 SELECT sex, avg(money) FROM users WHERE money \u0026gt; 5000 GROUP BY sex; -- 根据性别分组查询平均工资，只计算工资高于5000的数据, 且数据大于2条 SELECT sex, avg(money) FROM users WHERE money \u0026gt; 5000 GROUP BY sex HAVING COUNT(*) \u0026gt; 2; 分页查询 -- 语法 SELECT name SELECT name FROM users LIMIT 起始索引，查询数目量; -- 从0开始查，查询3条数据 SELECT name FROM users LIMIT 0，3; -- 分页查询 SELECT name FROM users LIMIT (当前页面 -1) * 每页显示条目数，每页显示条目数; ","permalink":"https://eoezora.github.io/posts/mysql-note/%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2/","summary":"SELECT -- 字段列表 FROM -- 表名列表 WHERE -- 条件列表 GROUP BY -- 分组列表 HAVING -- 分组后条件 ORDER BY -- 排序字段 LIMIT -- 限制查询返回数据的数量，用于分页限制 条件查询 -- 查询表里许所有数据,不建议使用 SELECT * FROM users; -- 查询名字 -- DISTINCT 去除重复 SELECT DISTINCT name FROM users; -- 查询名字，性别，年龄 -- 可以使用 sex as 性别 的方式对列起别名,也可以写成 sex 性别 省略as 但字段名跟别名之间要有空格隔开 SELECT name, sex as 性别, age as 年龄 FROM users; -- 条件查询符号, NULL值比较使用 IS NOT NULL 跟 IS NULL SELECT name FROM users WHERE age \u0026gt; 17; -- 查询age数值大于17的数据 SELECT name FROM users WHERE age \u0026gt;= 7 AND age \u0026lt;= 50; -- 查询age数值在7跟50之间的数值(写法一) SELECT name FROM users WHERE age BETWEEN 7 AND 50; -- 查询age数值在7跟50之间的数值(写法二) -- 查询brith_day数值在\u0026#39;2000-01-01\u0026#39;跟\u0026#39;2000-04-01\u0026#39;之间的数值(写法二) SELECT name FROM users WHERE brith_day BETWEEN \u0026#39;2000-01-01\u0026#39; AND \u0026#39;2000-04-01\u0026#39;; SELECT name FROM users WHERE age = 17; -- 查询age数值等于17的数据 SELECT name FROM users WHERE age !","title":"Mysql笔记-单表查询"},{"content":"24岁是学生，正在自学编程中，本站记录学习过程中的一些笔记\n","permalink":"https://eoezora.github.io/about/","summary":"24岁是学生，正在自学编程中，本站记录学习过程中的一些笔记","title":"🙋🏻‍♂️关于"}]